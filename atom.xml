<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蒙珣的博客</title>
  
  <subtitle>甚念伤吾生，正宜委运去。纵浪大化中，不喜亦不惧。应尽便须尽，无复独多虑。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-03-24T02:46:32.740Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>蒙珣</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第二章 进程与线程</title>
    <link href="http://example.com/2025/03/12/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2025/03/12/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2025-03-12T09:44:37.000Z</published>
    <updated>2025-03-24T02:46:32.740Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>重点内容</strong></p><ul><li><p>进程与线程</p><ul><li><strong>进程与线程的基本概念：进程/线程的状态与转换</strong></li><li>线程的实现：内核支持的线程，线程库支持的线程</li><li>进程与线程的组织与控制</li><li>进程间通信：共享内存，消息传递，管道</li></ul></li><li><p>CPU调度与上下文切换</p><ul><li><strong>调度的基本概念：调度的目标</strong></li><li>调度的实现：调度器/调度程序（schedule），调度的时机与调度方式（抢占式/非抢占式），闲逛进程，内核级线程与用户级线程调度</li><li>典型调度算法：先来先服务调度算法；短作业（短进程、短线程）优先调度算法，时间片轮转调度算法，优先级调度算法，高响应比优先级调度算法，多级队列调度算法，多级反馈队列调度算法</li><li>上下文及其切换机制</li></ul></li><li><p>同步与互斥</p><ul><li><strong>同步与互斥的基本概念</strong></li><li>基本的实现方法：软件方法；硬件方法</li><li><strong>锁：信号量</strong>；条件变量</li><li>经典同步问题：生产者-消费者问题，读者-写者问题；哲学家进餐问题</li></ul></li><li><p><strong>死锁</strong></p><ul><li><strong>死锁的基本概念；死锁预防</strong></li><li><strong>死锁避免；死锁检测和解除</strong></li></ul></li></ul><span id="more"></span><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="进程的概念与特征"><a href="#进程的概念与特征" class="headerlink" title="进程的概念与特征"></a>进程的概念与特征</h4><p><img src="01.png"></p><h4 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h4><h5 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h5><p><img src="02.png"></p><h5 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h5><p><img src="03.png"></p><h5 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h5><p>进程的组织分为两种方式，其一是链接方式，也就是链表。还有一种是索引方式，也就是哈希表。不过大多数操作系统都用的是链表方式</p><p><img src="04.png"></p><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p><img src="09.png"></p><h5 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h5><p><img src="05.png"></p><h5 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h5><p><img src="06.png"></p><h5 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h5><p><img src="07.png"></p><h5 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h5><p><img src="08.png"></p><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p><img src="10.png"></p><h4 id="线程和多线程模型"><a href="#线程和多线程模型" class="headerlink" title="线程和多线程模型"></a>线程和多线程模型</h4><p>引入线程机制后，有什么变化？</p><p><img src="11.png"></p><p><strong>线程的属性</strong></p><ul><li>线程是处理机调度的单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销大</li></ul><p><img src="12.png"></p><h4 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h4><h5 id="用户级线程user-level-thread-ult"><a href="#用户级线程（User-Level-Thread-ULT）" class="headerlink" title="用户级线程（User-Level Thread, ULT）"></a>用户级线程（User-Level Thread, ULT）</h5><p><img src="13.png"></p><ol><li><p><strong>线程的管理工作有谁来完成？</strong></p><p>用户级线程由应用程序通过线程库实现，所有的<font color="orange">线程管理工作都由应用程序负责</font>（包括线程切换）</p></li><li><p><strong>线程的切换是否需要CPU变态？</strong></p><p>用户级线程中，<font color="orange">线程切换</font>可以在<font color="orange">用户态下即可完成</font>，无需操作系统干预</p></li><li><p><strong>操作系统是否能意识到用户级线程的存在？</strong></p><p>在用户看来，是有多个线程。但是操作系统内核看来，并意识不到线程的存在。<font color="orange">“用户级线程”</font>就是<font color="orange">“从用户视角看能看到的线程”</font></p></li><li><p><strong>这种线程的实现方式有什么优点和缺点？</strong></p><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到内核态，线程管理的系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。<strong>多个线程不可在多核处理机上并行运行。</strong></p></li></ol><h5 id="内核级线程kernel-level-thread-klt"><a href="#内核级线程（Kernel-Level-Thread-KLT）" class="headerlink" title="内核级线程（Kernel-Level Thread, KLT）"></a>内核级线程（Kernel-Level Thread, KLT）</h5><p><img src="14.png"></p><ol><li><p><strong>线程的管理工作由谁来完成？</strong></p><p><font color="orange">内核级线程的管理工作</font>由<font color="orange">操作系统内核</font>完成</p></li><li><p><strong>线程的切换是否需要CPU变态？</strong></p><p>线程调度、切换等工作都由内核负责，因此<font color="orange">内核级线程的切换</font>必然需要<font color="orange">核心态</font>下才能完成。</p></li><li><p><strong>操作系统是否能意识到内核级线程的存在？</strong></p><p>操作系统会为内个内核级线程创建相应的TCB（Thread Control Block，线程控制块），通过TCB对线程进行管理。<font color="orange">“内核级线程”</font>就是<font color="orange">“从操作系统内视角看能看到的线程”</font></p></li><li><p><strong>这种线程的实现方式有什么优点和缺点？</strong></p><p>优点：当一个线性被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在内核处理机上并行运行。</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p></li></ol><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><h5 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h5><p><img src="15.png"></p><p>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行运行。</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换核心态，因此线程管理的成本高，开销大。</p><h5 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h5><p><img src="16.png"></p><p>多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态（而是通过用户库），线程管理的系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p><h5 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h5><p><img src="17.png"></p><p>多对多模型：n个用户级线程映射到m个内核级线程（n &gt;= m）。每个用户进程对应m个内核级线程。</p><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p><p><strong>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞</strong></p><h4 id="线程的组织与控制"><a href="#线程的组织与控制" class="headerlink" title="线程的组织与控制"></a>线程的组织与控制</h4><p><img src="18.png"></p><h3 id="cpu调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><h4 id="调度的时机-切换与过程-方式"><a href="#调度的时机、切换与过程、方式" class="headerlink" title="调度的时机、切换与过程、方式"></a>调度的时机、切换与过程、方式</h4><p><strong>进程切换的时机</strong></p><ol><li>什么时候需要进程调度</li><li>什么时候不能进行进程调度</li></ol><p><img src="19.png"></p><p><strong>临界资源：</strong>一个时间段内只允许一个进程使用的资源。各进程需要<font color="orange">互斥地</font>访问临界资源</p><p><strong>临界区：</strong>访问临界资源的那段代码</p><p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。例如：进程访问打印机</p><p><strong>进程切换与过程</strong></p><ol><li><p>“狭义的调度”与“切换”的区别</p><p><font color="orange"><strong>狭义的进程调度</strong></font>：从就绪队列中选中一个要运行的进程（这个进程可以使刚刚被暂停执行的进程，也可能是另一个进程）</p><p>进程切换：一个进程让出处理机，由另外一个占用处理机。</p><p><font color="orange"><strong>广义的进程调度</strong></font>：包含了进程调度和进程切换两个不走</p></li><li><p>进程切换的过程需要做什么？</p><p>对原来运行的进程各种数据的保存</p><p>对新的进程各种数据的恢复</p><p>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般都保存在进程控制块中）</p></li></ol><p><strong>进程调度的方式</strong></p><ol><li><p>非剥夺调度方式（非抢占式）</p><p>实现简单，系统开销小但是无法及时处理紧急任务，<strong>适合于早期的批处理系统</strong></p></li><li><p>剥夺调度方式（抢占式）</p><p>可优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。<strong>适合于分时操作系统、实时操作系统</strong></p></li></ol><p><strong>进程调度的时机</strong></p><ul><li><font color="orange">创建新进程</font></li><li><font color="orange">进程退出</font></li><li>运行<font color="orange">进程阻塞</font></li><li><font color="orange">I/O中断</font>发生（可能唤醒某些阻塞进程）</li></ul><ul><li>非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作</li><li>抢占式调度策略，每个<font color="orange">时钟中断</font>或K歌时钟中断会触发调度程序工作</li></ul><h4 id="闲逛进程的特性"><a href="#闲逛进程的特性" class="headerlink" title="闲逛进程的特性"></a><strong>闲逛进程的特性</strong></h4><ul><li><p>优先级最低</p></li><li><p>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</p></li><li><p>能耗低</p></li></ul><h4 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h4><p><img src="20.png"></p><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="先来先服务fcfs"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h5><p><img src="21.png"></p><h5 id="短作业优先sjf"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h5><p><font color="orange">抢占式的</font>短作业/进程优先调度算法（<font color="orange">最短剩余时间优先，SRNT</font>算法）的平均等待时间、平均周转时间最少</p><p>或者，在<font color="orange">所有进程都几乎同时到达</font>时，采用SJF调度算法的平均等待时间、平均周转时间最少</p><p><font color="orange">SRTN的平均等待时间、平均周转时间最少</font></p><p><img src="22.png"></p><h5 id="高响应比优先hrrn"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a>高响应比优先（HRRN）</h5><p><img src="23.png"></p><p>接下来看一下他们的比较</p><p><img src="24.png"></p><h5 id="时间片轮转rr-round-robin"><a href="#时间片轮转（RR-Round-Robin）" class="headerlink" title="时间片轮转（RR, Round-Robin）"></a>时间片轮转（RR, Round-Robin）</h5><p><img src="25.png"></p><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p><img src="26.png"></p><ul><li>系统进程优先级 <strong>高于</strong> 用于进程</li><li>前台进程优先级 <strong>高于</strong> 后台进程</li><li>操作系统 **更偏好 **I/O繁忙型进程</li></ul><p><strong>动态优先级</strong></p><ul><li>和上面静态优先级相对应的是动态优先级。创建进程时先赋予进程⼀个优先级，但优先级会随进程的推进或等待时间的增加⽽改变，以便获得更好的调度性能。例如，规定优先级随等待时间的增加⽽提⾼，于是，对于优先级初值较低的进程，等待⾜够长的时间后也可获得CPU</li></ul><h5 id="多级队列反馈算法"><a href="#多级队列反馈算法" class="headerlink" title="多级队列反馈算法"></a>多级队列反馈算法</h5><p>多级队列反馈算法综合了</p><ul><li>FCFS算法的公平，</li><li>SJF算法能尽快处理完短作业，平均等待/周转时间等参数很优秀</li><li>时间片调度轮转算法可以让各个进程得到及时的响应</li><li>优先级调度算法可以灵活地调整各种进程被服务的机会</li></ul><p>下面的例子很好的说明了这个算法</p><p><img src="27.png"></p><p><img src="28.png"></p><p><strong>接下来看一下他们的比较</strong></p><p><img src="29.png"></p><p><img src="24.png"></p><h5 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h5><p><img src="30.png"></p><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><h4 id="同步与互斥的基本概念"><a href="#同步与互斥的基本概念" class="headerlink" title="同步与互斥的基本概念"></a>同步与互斥的基本概念</h4><p>异步：和同步相对，同步是顺序执行，而异步是彼此独立，在等待某个事件的过程中继续做自己的事，不要等待这一事件完成后再工作。线程是实现异步的一个方式，异步是让调用方法的主线程不需要同步等待另一个线程的完成，从而让主线程干其他事情。</p><p>异步：在并发环境中，各任务各自独立执行，相互之间互不干扰。</p><p><img src="31.png"></p><h4 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h4><h5 id="单标志法违背空闲让进"><a href="#单标志法（违背空闲让进）" class="headerlink" title="单标志法（违背空闲让进）"></a>单标志法（违背空闲让进）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> turn = <span class="number">0</span>;<span class="comment">// turn 表示当前允许进入临界区的进程号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P0进程</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);<span class="comment">// 进入区</span></span><br><span class="line">critical section;<span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;<span class="comment">// 退出区</span></span><br><span class="line">remainder section;<span class="comment">// 执行剩余代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P1进程</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>该算法<font color="orange">可以实现“同一时刻最多只允许一个进程访问临界区”</font></p><p>但是当P1进程先执行时，就会陷入“死”循环，需要等到时间片用完才可切换P0进程。因此<font color="orange">违背了实现临界区互斥必须遵循的“空闲让进”原则</font></p><h5 id="双标志检查法"><a href="#双标志检查法" class="headerlink" title="双标志检查法"></a>双标志检查法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// 刚开始设置两个进程都不想进入临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P0 进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);<span class="comment">// 如果此时 P0 想进入临界区，P1 就一直循环等待</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// 标记为 P1 进程想要进入临界区</span></span><br><span class="line">critical section;<span class="comment">// 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// 访问完临界区，修改标记为 P1 不想使用临界区</span></span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1 进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">critcal section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>如果连个进程交替执行，此时他俩几乎同时跳过了检查，所以导致都可以进入临界区。</p><p>因此，双标志先检查法的<font color="orange">主要问题是：违反了“忙则等待”的原则</font></p><p>原因在于，检查和上锁不是一气呵成的，在检查后，上锁前可发生进程切换</p><h5 id="双标志后检查法违背空闲让进-有限等待"><a href="#双标志后检查法（违背空闲让进、有限等待）" class="headerlink" title="双标志后检查法（违背空闲让进、有限等待）"></a>双标志后检查法（违背空闲让进、有限等待）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// 刚开始设置两个进程都不想进入临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P0 进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// 标记为 P1 进程想要进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);<span class="comment">// 如果此时 P0 想进入临界区，P1 就一直循环等待</span></span><br><span class="line">critical section;<span class="comment">// 访问临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// 访问完临界区，修改标记为 P1 不想使用临界区</span></span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1 进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);</span><br><span class="line">critcal section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>由于先上锁，后检查。在两个进程并发执行时，会导致两个进程互相争抢进入临界区，谁也不让谁进入，导致饥饿现象。</p><p>虽然解决了“忙则等待”，但是违背了“空闲让进”和“优先等待”</p><h5 id="peterson算法未遵守让权等待"><a href="#Peterson算法（未遵守让权等待）" class="headerlink" title="Peterson算法（未遵守让权等待）"></a>Peterson算法（未遵守让权等待）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P0 进程：</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// 主动争取进入临界区</span></span><br><span class="line">turn = <span class="number">1</span>;<span class="comment">// 主动谦让</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn = <span class="number">1</span>);<span class="comment">// 对方想进，且最后一次自己让梨，那自己就循环等待</span></span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = flag;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1 进程：</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">// 表示自己想要进入临界区</span></span><br><span class="line">turn = <span class="number">0</span>;<span class="comment">// 可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn = <span class="number">0</span>);<span class="comment">// 对方想进，且最后一次自己让梨，那自己就循环等待</span></span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = flag;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p><strong>Peterson 算法用软件方法解决了进程互斥问题，<font color="orange">遵循了空闲让进、忙则等待、优先等待三个原则，但是仍然未遵守让权等待的原则</font></strong></p><p><img src="32.png"></p><h4 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h4><h5 id="中断屏蔽法适用于单处理机-内核进程"><a href="#中断屏蔽法（适用于单处理机、内核进程）" class="headerlink" title="中断屏蔽法（适用于单处理机、内核进程）"></a>中断屏蔽法（适用于单处理机、内核进程）</h5><p><img src="33.png"></p><h5 id="testandset指令不满足让权等待适用于多cpu"><a href="#TestAndSet指令（不满足让权等待，适用于多CPU）" class="headerlink" title="TestAndSet指令（不满足让权等待，适用于多CPU）"></a>TestAndSet指令（不满足让权等待，适用于多CPU）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">// true 表示已加锁，false 表示未加锁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">bool</span> *lock)</span></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> old;</span><br><span class="line">  old = *lock;<span class="comment">// old 用来存放 lock 原来的值</span></span><br><span class="line">  *lock = <span class="literal">true</span>;<span class="comment">// 无论之前是否已加锁，都将 lock 设为 true</span></span><br><span class="line">  <span class="keyword">return</span> old;<span class="comment">// 返回 lock 原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用 TSL 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock));<span class="comment">// 上锁并检查</span></span><br><span class="line">临界区代码段</span><br><span class="line">lock = <span class="literal">false</span>;<span class="comment">// 解锁</span></span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure><p>TSL 指令把上锁和检查操作用硬件的方式变成了一气呵成的的原子操作。</p><p>优点：</p><ul><li>实现简单，无需像让见实现方法那样严格检查是否会有逻辑漏洞</li><li>适用于多处理机环境</li></ul><p>缺点：</p><ul><li>不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”</li></ul><h5 id="swap指令不满足让权等待-适用于多cpu"><a href="#Swap指令（不满足让权等待、适用于多CPU）" class="headerlink" title="Swap指令（不满足让权等待、适用于多CPU）"></a>Swap指令（不满足让权等待、适用于多CPU）</h5><p>Swap 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap 指令的作用是交换两个变量的值</span></span><br><span class="line">Swap (<span class="keyword">bool</span> *a, <span class="keyword">bool</span> *b)&#123;</span><br><span class="line">  <span class="keyword">bool</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是用 Swap 指令实现互斥的逻辑算法</span></span><br><span class="line"><span class="comment">// lock表示当前临界区是否被加锁</span></span><br><span class="line"><span class="keyword">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)</span><br><span class="line">  Swap (&amp;lock, &amp;old);</span><br><span class="line">临界区代码段...</span><br><span class="line">lock = fasle;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>实现简单，无需像让见实现方法那样严格检查是否会有逻辑漏洞</li><li>适用于多处理机环境</li></ul><p>缺点：</p><p>不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行Swap指令，从而导致“忙等”</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;重点内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程与线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程与线程的基本概念：进程/线程的状态与转换&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;线程的实现：内核支持的线程，线程库支持的线程&lt;/li&gt;
&lt;li&gt;进程与线程的组织与控制&lt;/li&gt;
&lt;li&gt;进程间通信：共享内存，消息传递，管道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CPU调度与上下文切换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;调度的基本概念：调度的目标&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;调度的实现：调度器/调度程序（schedule），调度的时机与调度方式（抢占式/非抢占式），闲逛进程，内核级线程与用户级线程调度&lt;/li&gt;
&lt;li&gt;典型调度算法：先来先服务调度算法；短作业（短进程、短线程）优先调度算法，时间片轮转调度算法，优先级调度算法，高响应比优先级调度算法，多级队列调度算法，多级反馈队列调度算法&lt;/li&gt;
&lt;li&gt;上下文及其切换机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同步与互斥&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同步与互斥的基本概念&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;基本的实现方法：软件方法；硬件方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;锁：信号量&lt;/strong&gt;；条件变量&lt;/li&gt;
&lt;li&gt;经典同步问题：生产者-消费者问题，读者-写者问题；哲学家进餐问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;死锁的基本概念；死锁预防&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁避免；死锁检测和解除&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>第一章 计算机系统概述</title>
    <link href="http://example.com/2025/03/08/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2025/03/08/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2025-03-08T08:27:09.000Z</published>
    <updated>2025-03-17T05:45:44.741Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>重点内容</strong></p><ul><li>操作系统的基本概念</li><li>操作系统的发展历程</li><li>程序运行环境<ul><li>CPU运行模式：内核模式与用户模式</li><li>中断和异常的处理；系统调用</li><li>程序的链接与装入；程序运行时内存映像与地址空间</li></ul></li><li>操作系统结构<ul><li>分层、模块化、宏内核、微内核、外核</li></ul></li><li>操作系统引导</li><li>虚拟机</li></ul><span id="more"></span><h3 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h3><p><img src="01.png"></p><h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><p><img src="02.png"></p><ul><li><strong><font color="orange">理解并发与并行的区别</font></strong></li><li><strong><font color="orange">并发与共享互为存在条件</font></strong></li><li><strong><font color="orange">没有并发和共享，就谈不上虚拟和异步，因此并发和共享式操作系统的两个最基本的特征</font></strong></li></ul><h3 id="操作系统发展历程"><a href="#操作系统发展历程" class="headerlink" title="操作系统发展历程"></a>操作系统发展历程</h3><p><img src="03.png"></p><h3 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h3><h4 id="处理器运行模式"><a href="#处理器运行模式" class="headerlink" title="处理器运行模式"></a>处理器运行模式</h4><p><img src="04.png"></p><h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h4><p><img src="05.png"></p><p><img src="06.png"></p><p>**<font color="orange">需要注意的是</font>**：</p><ul><li><p><strong>将CPU模式改为内核态是硬件自动完成的，通过修改PSW中的<code>CS:RFLAGS:SS:RSP</code>完成切换</strong></p></li><li><p><strong>而中断向量表是通过数组实现的。时间上可以实现O(1)。</strong></p></li></ul><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p><img src="07.png"></p><h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><p><img src="08.png"></p><p><img src="09.png"></p><p><img src="10.png"></p><h3 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h3><p><img src="11.png"></p><p>计算机的启动顺序：</p><ul><li><p>CPU加电，CS:IP 指向 FFFF0H</p><p>计算机加电后，CPU 需要从一个固定的地址开始执行指令。这是因为计算机刚启动时，内存是空的，必须依靠固化在主板上的 <strong>BIOS（基本输入输出系统）</strong> 来完成最初的初始化操作。</p><p><strong>为什么是 FFFF0H？</strong> 这个地址位于 CPU 地址空间的最顶端（1MB 内存的倒数 16 字节处），这个区域的 ROM 固定存储着 <strong>BIOS 的启动代码</strong>。这样，无论计算机如何启动，CPU 总是能找到 BIOS 代码并执行。</p></li><li><p>执行 JMP 指令跳转到 BIOS</p><p>FFFF0H是跳转指令，会让CPU跳转到BIOS的起始地址，让 BIOS 开始执行。</p></li><li><p>登记 BIOS 中断程序入口地址</p><p>BIOS 负责提供基本的输入输出功能，比如键盘、屏幕、硬盘等设备的访问。在计算机启动过程中，BIOS 会在内存中 <strong>设置中断向量表</strong>，登记这些设备的 <strong>中断处理程序</strong>（Interrupt Service Routine, ISR），让后续的软件可以通过 <strong>中断调用</strong>（INT 指令）访问这些硬件。</p></li></ul><ul><li><p>硬件自检</p><p>计算机刚开机时，可能有硬件损坏或未正确连接。BIOS 会运行 <strong>POST（加电自检）</strong> 代码，检查硬件是否正常</p></li><li><p>进行操作系统引导</p><p>BIOS 会从 <strong>引导设备</strong>（通常是硬盘、U 盘、光盘）读取 <strong>引导扇区（Boot Sector）</strong>，然后 <strong>跳转到引导程序</strong>（如 Windows Boot Manager 或 Linux GRUB），由引导程序加载完整的操作系统。</p></li></ul><p><strong>那么为什么要这么早的登记中断向量表呢？如果在硬件自检完成后不可以吗？</strong>当时我一直有这样一个疑问</p><p>这是ChatGPT给出的回答</p><p>事实上，<strong>BIOS 在整个启动过程中会多次修改和更新中断向量表</strong>，但它确实会在 <strong>硬件自检（POST）之前</strong> <strong>初始化基本的中断向量表</strong>，主要有以下几个原因：</p><hr><p><strong>1. CPU 可能需要处理异常</strong></p><p>​    •    在计算机启动时，CPU 可能会遇到异常（例如除零错误、非法指令等）。如果 <strong>中断向量表未初始化</strong>，CPU 碰到异常时就 <strong>无法找到正确的处理程序</strong>，可能导致系统崩溃或未定义行为。</p><p>​    •    通过 <strong>预先登记基础的中断处理程序</strong>（比如 BIOS 提供的默认异常处理），可以确保 CPU 在任何情况下都能有一个合理的响应，而不会直接死机。</p><hr><p><strong>2. 确保基本 I/O 功能可用（如屏幕输出、蜂鸣器报警）</strong></p><p>​    •    <strong>POST 过程中</strong>，BIOS 可能需要 <strong>在屏幕上显示信息</strong>（如 “Memory Test Passed”）或者 <strong>蜂鸣器报警</strong>（如 RAM 或显卡错误）。</p><p>​    •    这些功能通常依赖 <strong>BIOS 提供的中断服务</strong>（如 INT 10H 处理显示输出、INT 16H 处理键盘输入等）。</p><p>​    •    如果等 <strong>自检后</strong> 才登记这些中断向量，BIOS <strong>在自检过程中就无法打印信息或报警</strong>，用户就无法知道硬件是否正常工作。</p><hr><p><strong>3. 让 BIOS 自己能调用中断</strong></p><p>​    •    <strong>BIOS 本身</strong> 也可能在 POST 期间调用某些中断（如 INT 13H 访问存储设备、INT 19H 引导系统）。</p><p>​    •    这些中断程序必须 <strong>先登记好</strong>，否则 BIOS 运行时自己调用它们就会出错。</p><hr><p><strong>4. 硬件自检可能依赖某些 BIOS 中断</strong></p><p>​    •    <strong>某些硬件检测过程</strong> 可能需要调用 BIOS 中断，比如：</p><p>​    •    访问 <strong>CMOS</strong> 读取系统时间（INT 1AH）。</p><p>​    •    检测硬盘是否存在（INT 13H）。</p><p>​    •    显示显卡信息（INT 10H）。</p><p>​    •    如果等到 POST 完成后才登记这些中断，BIOS <strong>在自检过程中就无法使用它们</strong>，影响自检结果。</p><hr><p><strong>5. 之后仍会更新和修正中断向量表</strong></p><p>​    •    <strong>早期登记的中断向量</strong> 只是 BIOS 的 <strong>初始版本</strong>，通常只是占位或提供基本功能。</p><p>​    •    <strong>POST 结束后</strong>，如果有更好的中断服务（比如 <strong>扩展 BIOS、驱动程序、操作系统引导程序</strong>），它们 <strong>可以覆盖或修改</strong> 这些中断向量。例如：</p><p>​    •    <strong>显卡 BIOS</strong> 可能会提供更高级的 INT 10H（视频功能）。</p><p>​    •    <strong>磁盘驱动程序</strong> 可能会提供更高效的 INT 13H（磁盘访问）。</p><p>​    •    <strong>操作系统</strong> 会接管 INT 21H（DOS 系统调用）等。</p><hr><p><strong>总结</strong></p><p><strong>在硬件自检（POST）之前登记 BIOS 中断表，主要是为了让 CPU、BIOS 和基本硬件在整个启动过程中能正确工作。</strong></p><p>如果不提前登记，BIOS <strong>在自检过程中就无法使用中断</strong>，可能导致无法显示信息、无法检测硬件、甚至无法处理 CPU 异常，从而让计算机启动失败。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p><img src="12.png"></p><p><img src="13.png"></p><p>值得注意的是，支持虚拟化的CPU通常分更多指令等级。这样就不至于任何特权指令都要经过虚拟机处理，导致性能下降严重了</p><p><img src="14.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;重点内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统的基本概念&lt;/li&gt;
&lt;li&gt;操作系统的发展历程&lt;/li&gt;
&lt;li&gt;程序运行环境&lt;ul&gt;
&lt;li&gt;CPU运行模式：内核模式与用户模式&lt;/li&gt;
&lt;li&gt;中断和异常的处理；系统调用&lt;/li&gt;
&lt;li&gt;程序的链接与装入；程序运行时内存映像与地址空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统结构&lt;ul&gt;
&lt;li&gt;分层、模块化、宏内核、微内核、外核&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统引导&lt;/li&gt;
&lt;li&gt;虚拟机&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>存储系统</title>
    <link href="http://example.com/2025/03/07/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2025/03/07/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</id>
    <published>2025-03-07T09:25:22.000Z</published>
    <updated>2025-03-08T08:18:55.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>计算机组成原理随缘更新，因为内容点比较多，所以主讲原理，也算是自我复习。另外</p><p>《编码》这本书的自动操作写了一些，不知道啥时候有空给整完。</p><p>存储系统这一章还是和操作系统关联比较强的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="计算机组成原理与设计" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>自动操作</title>
    <link href="http://example.com/2025/01/21/%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2025/01/21/%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2025-01-21T10:54:36.000Z</published>
    <updated>2025-02-09T08:33:41.826Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>上一章，我们已经可以创建 64K * 8存储器了，这一章我们来让我们的处理器拥有计算乘法的能力。</p><p>如果我们要计算 17 * 4 就需要在控制面板中连续输入四次17的二进制，来让加法器计算。这样费时耗力，如果是 123 * 456呢，反正我是不会做这种枯燥的事情</p><span id="more"></span><p>现在让我们回顾一下我们之前制作的加法器吧。</p><p>我们的加法器拥有一个8位锁存器，来保存8位数据。有但很明显，它无法显示超过255以上的数，如图。</p><p><img src="01.png"></p><p>锁存器的结果会显示在灯泡上，并作为加法器下一次加法的加数。</p><p>在本章中，我们将使用边沿触发器，边沿触发器在很多方面更加易于使用。</p><p>我们需要知道，**用来累加多个数的锁存器称做累加器(accumulator)**，即用于保存加法器的输出结果，上图的8位锁存器和加法器就构成了一个累加器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一章，我们已经可以创建 64K * 8存储器了，这一章我们来让我们的处理器拥有计算乘法的能力。&lt;/p&gt;
&lt;p&gt;如果我们要计算 17 * 4 就需要在控制面板中连续输入四次17的二进制，来让加法器计算。这样费时耗力，如果是 123 * 456呢，反正我是不会做这种枯燥的事情&lt;/p&gt;</summary>
    
    
    
    
    <category term="编码——隐匿在计算机软硬件背后的语言" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>存储器组织</title>
    <link href="http://example.com/2025/01/18/%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/"/>
    <id>http://example.com/2025/01/18/%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87/</id>
    <published>2025-01-18T11:07:06.000Z</published>
    <updated>2025-01-18T12:27:09.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在这一章，我们将一步步搭建一个 64K * 8 的RAM阵列，而所用到的触发器正是我们之前所学到的D电平触发器。</p><span id="more"></span><p>这里我们稍微改造一下之前的D触发器，将时钟输入端换个名称叫做<strong>写操作端</strong>，将数据端叫做<strong>数据输入</strong>，并且这里没有Q非。</p><p><img src="01.png"></p><p>它的简化图为</p><p><img src="02.png"></p><p>我们很容易想到将其组织成多位锁存器，它的逻辑结构为</p><p><img src="03.png"></p><p>它的简化图为</p><p><img src="04.png"></p><p><img src="05.png"></p><p>但这种锁存器有一个问题，就是他只能统一写入一个数。我们希望锁存器能将输入信号数据分8次独立存储，也就是说：<strong>我们只想存储8个单独的比特，而不是存储1个8位二进制数。</strong></p><h3 id="8-1选择器8-line-to-1-line-data-selector"><a href="#8-1选择器（8-Line-to-1-Line-Data-Selector）" class="headerlink" title="8-1选择器（8-Line-to-1-Line Data Selector）"></a>8-1选择器（8-Line-to-1-Line Data Selector）</h3><p>为了解决这个问题，我们可以使用8-1选择器来解决这个问题</p><p><img src="06.png"></p><p>选择输入端的功能就是选择一个输入端数据，然后使其在输出端输出。如果选择输入端为000，则将D0锁存器的值输出；若选择端为111，则D7锁存器的值将被输出；若选择端为101，则相应地输出D5的值。系统的真值表如下所示</p><p><img src="07.png"></p><p>8-1选择器主要组成部件为：三个反向器、八个4端口输入与门、一个8端口输入或门，系统的组织结构如下图所示。</p><p><img src="08.png"></p><p><strong>注意D0-D7数据端与S0-S2选择端的链接方式，例如：D1中的S0不经过反向器</strong></p><p>我们的目的是通过某种方式连接8个1位锁存器，使自己能够从一个输入信号端写入数据，还能从一个输出信号端鉴别出数据。现在我们已经成功地使用了一个8-1选择器对8个锁存器进行了选择操作，并将相应锁存器的数据输出，下面是电路的结构图。</p><p><img src="09.png"></p><h3 id="3-8译码器3-to-8-decoder"><a href="#3-8译码器（3-to-8-Decoder）" class="headerlink" title="3-8译码器（3-to-8-Decoder）"></a>3-8译码器（3-to-8-Decoder）</h3><p>输入端包括了数据输入信号及写操作信号。可以把所有数据输入信号在锁存器的输入端连接在一起。但<strong>8个写入信号是不可以连在一起的，因为我们很可能要向每个锁存器依次写入数据。</strong>除此之外<strong>还需要一个独立的写入信号，它能被路由到任意（且唯一）的锁存器上</strong>，所以我们还需要一个3-8译码器，来控制输入。</p><p>3-8译码器每次只会有一个锁存器输出为1，其余均为0</p><p><img src="10.png"></p><p>它的逻辑表如下：</p><p><img src="11.png"></p><p>现在我们将3-8译码器加入到电路中就形成了完整的系统</p><p><img src="12.png"></p><p>值得注意的是，译码器和选择器具有相同的选择信号，在上图中这三个信号一起被称为地址端口(Address)。</p><h3 id="8x1-ram-与-ram阵列"><a href="#8x1-RAM-与-RAM阵列" class="headerlink" title="8x1 RAM 与 RAM阵列"></a>8x1 RAM 与 RAM阵列</h3><p>这种配置下的锁存器在有的资料中也被称为读/写存储器(read/write memory)，但更普遍的叫法是随机访问存储器(Random Access Memory)，或RAM（和单词animal发音类似）。可以认为我们讨论的这种存储器是可存储8个独立比特的RAM，它的简化结构图如下所示。</p><p><img src="13.png"></p><p>上图所示的电路之所以能够被称为存储器是因为它可以保存信息。而能够被称为<strong>读/写存储器</strong>是因为它<strong>不仅可以在每个锁存器中存储新的数据（可以把这种功能称为写数据）</strong>，而且我们<strong>还可以检查每个锁存器都保存了什么数据（可以把这种功能称为读数据）</strong>。<strong>之所以可以被称为随机访问存储器，是因为读写操作很自由，我们只需要改变地址及相关的输入，就可以从8个锁存器中读出或写入需要的数据</strong>。相比于其他的顺序型的存储器——这种存储器在使用时有一定的限制，如果想要读取地址为101的数据，必须先把地址为100的数据读取出来。</p><p>**将RAM进行特殊的配置可形成RAM阵列(Array)**，我们所讨论的这种RAM阵列以8×1（读做8乘1）的方式组织起来。阵列以1比特作为存储单位，共存储8个单位的数据。所以这个RAM阵列中能存储的位数等于8与1的乘积。</p><p>RAM阵列的组合形式多种多样。比如<strong>我们可以通过共享地址的方式可以把两个8×1的RAM阵列连接起来</strong>，如下图所示。</p><p><img src="14.png"></p><p>我们把这两个8×1的RAM阵列的地址和输出都分别看成一个整体，这样就得到了一个8×2的RAM阵列，如下图所示。</p><p><img src="15.png"></p><p>需要注意的是：这个RAM阵列可存储的二进制数依然是8个，但它的位宽为2位。即它可以存储8个2位的二进制数</p><p>我们还可以把两个8×1的RAM阵列看做是两个锁存器，使用一个2-1选择器和一个1-2译码器就可以把它们按照单个锁存器连接方式进行集成，下面给出了这种方案的电路图。他可以<strong>存储16个1位的二进制数</strong></p><p><img src="16.png"></p><p>我们将选择端连上了译码器和选择器，主要作用是在两个8*1 RAM阵列中选择一个输出，本质上它扮演了第4根地址线的角色。因此这种结构实质上是一种16×1的RAM阵列，如下图所示。这样我们就可以用它来存储16个1位的二进制数了。</p><p><img src="17.png"></p><p>上图所示的RAM阵列存储容量为16个单位，每个单位占1位。</p><p>你是否有发现RAM阵列的存储容量与地址输入端个数的关系呢？</p><p><font color="orange">RAM阵列的存储容量=2^地址输入端的个数</font></p><h4 id="64k8-ram"><a href="#64K-8-RAM" class="headerlink" title="64K*8 RAM"></a>64K*8 RAM</h4><p>同样的我们可以搭建一个更大规模的RAM阵列</p><p><img src="18.png"></p><p>这个RAM阵列需要配备16位的寻址端。换句话说，该地址恰好可以用2个字节表示。将地址范围转化为十六进制就是0000h～FFFFh。</p><p>值得一提的是：存储一个比特位需要9个继电器，而我们搭建的这个64K*8的RAM阵列至少需要500万个继电器，值得骄傲一下。</p><p>这里我们可以用一个控制面板来辅助我们管理这块64KB存储器的操作——包括写操作和读数据</p><p><img src="19.png"></p><p>初始状态下所有的开关均置为0。其中右下角有一个标识为控制端(takeover)的开关，这个开关的作用是确定由控制面板还是由外部所连接的其他电路来控制存储器。如果其他电路连接到与控制面板相连的存储器，这时控制端置0（如图所示），此时存储器由其他电路系统接管，控制面板上的其他开关将不起任何作用；当控制端置1时，控制面板将重新获得对存储器的控制能力。</p><p>这种功能可以用一些2-1选择器来实现。仔细数一下会发现，我们需要25个2-1选择器——其中包括16个地址输入端、8个数据输入端，以及1个写操作端。电路如下图所示。</p><p>当控制端开关断开时，RAM阵列的地址端、数据输入和写操作端的数据全部来源于外部信号，也就是在2-1选择器的左上角的输入信号；当控制端开关闭合，RAM阵列的地址端、数据输入端和写操作端的数据来源于控制面板开关发出的信号。但最终RAM阵列的输出信号都会传输到8个灯泡上或其他可能的地方。</p><p><img src="20.png"></p><p>下面这幅是控制面板与64K×8 RAM阵列的逻辑结构框图。</p><p><img src="21.png"></p><p>当控制端开关闭合时，通过操作16个地址开关，可以选择65,536个地址中的任何一个，灯泡的状态将表示该地址中所保存的8位数据。我们可以使用8个数据开关表示出一个新数，然后把写操作端置1，从而将数据写入存储器。</p><p>64K×8的RAM阵列和控制面板这一组合的确很实用，它可以帮助我们存储65,536个8位数据并且读取其中的任意一个。与此同时，我们也给其他部件提供了接入系统的机会——需要接入系统的通常是一些电路部件——这些部件可以轻易地读取并利用存储器中存放的数据，还可以把数据写入存储器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在这一章，我们将一步步搭建一个 64K * 8 的RAM阵列，而所用到的触发器正是我们之前所学到的D电平触发器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="编码——隐匿在计算机软硬件背后的语言" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>反馈与触发器</title>
    <link href="http://example.com/2025/01/17/%E5%8F%8D%E9%A6%88%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://example.com/2025/01/17/%E5%8F%8D%E9%A6%88%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2025-01-17T09:55:40.000Z</published>
    <updated>2025-01-18T04:22:13.505Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><p>非常重要的一章内容，相对之前章节也要更难一些。可以参考b站视频辅助学习</p><p><a href="https://www.bilibili.com/video/BV1oL411D77D?spm_id_from=333.788.videopod.sections&vd_source=7edae3cd790e850cc7836ab5c5d9ac4b">锁存器与触发器详解合集</a></p><span id="more"></span><h3 id="2-1选择器"><a href="#2-1选择器" class="headerlink" title="2-1选择器"></a>2-1选择器</h3><p>2-1选择器使用了8个如下所示的电路。</p><p><img src="00.png"></p><p>如果选择端(Select)输入是1，那么或门的输出和B端的输入就是一致的。这是因为上面与门的输出和B端输入是一样的，而下面与门的输出是0。类似的，如果选择端的输入是0，那么或门的输出则和A端输入一致。总结起来如下表所示。</p><p><img src="000.png"></p><h3 id="反馈与触发器feedback-amp-flip-flop"><a href="#反馈与触发器（feedback-amp-Flip-Flop）" class="headerlink" title="反馈与触发器（feedback &amp; Flip-Flop）"></a>反馈与触发器（feedback &amp; Flip-Flop）</h3><h4 id="振荡器oscillator"><a href="#振荡器（oscillator）" class="headerlink" title="振荡器（oscillator）"></a>振荡器（oscillator）</h4><p>我们可以下图这个继电器来实现一个蜂鸣器。当继电器开关闭合后，金属簧片就会上下跳动——电路也会随之连通或断开——声音也就会随之发出。</p><p><img src="01.png"></p><br><p><img src="02.png"></p><br><p><img src="03.png"></p><p>闭合开关导致，导致电磁铁产生磁性，将金属簧片拉下来。当金属簧片断开时，电路也就不联通了。此时，因为物理结构，金属簧片又会弹回原位，导致电路再次连通。即我们就形成了一个蜂鸣器（需要你在簧片上绑一个小锤子，旁边再放一个锣）</p><p>此电路可以简化为一个反向器。</p><p><img src="04.png"></p><p>当反向器输入0时，他就输出1；当输入1时，输出就为0。电路中的开关一旦闭合，反向器中的继电器就会在连通与断开这两种状态之间反复交替。你也可以将电路中的开关省去，这样就可以使反向器连续地工作，如下所示。</p><p><img src="05.png"></p><p>电路的输出是什么呢？其实就是要么提供电压，要么不提供电压，在两者之间切换。我们也可以换种方式来表达——输出结果要么是0，要么是1。</p><p>我们把这种电路称为振荡器(oscillator)，振荡器却在不需要人干涉的情况下，可以完全自发地工作。振荡器有着举足轻重的作用。<strong>为了使不同组件同步工作，所有计算机都配备着某种振荡器。</strong></p><p><img src="06.png"></p><p>这幅图表示随着时间的推移，振荡器的输出在0和1之间按照固有的规律交替变化。正因为这一点，<strong>振荡器又经常被称为时钟(clock)，通过振荡进行计数也是一种计时方式。</strong></p><p><img src="07.png"></p><p>周期的倒数就是振荡器的频率(frequency)。在这个例子中振荡器的周期是0.05s，那么其频率就是1÷0.05s，即振荡器每秒钟产生20次循环，而相应的输出每秒钟也变化20次。<strong>因此振荡器的频率就是20赫兹，记做20 Hz</strong></p><h4 id="反馈与触发器feedback-amp-flip-flop"><a href="#反馈与触发器（feedback-amp-Flip-Flop）-1" class="headerlink" title="反馈与触发器（feedback &amp; Flip-Flop）"></a>反馈与触发器（feedback &amp; Flip-Flop）</h4><p>让我们来回顾一下或非门的逻辑。只有在两端输入都没有电压时输出才有电压</p><table><thead><tr><th align="center">NOR</th><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><p>下面是一个包含两个或非门、两个开关和一个灯泡的电路。</p><p><img src="08.png"></p><p>值得注意的是这种特殊的弯曲的连线方式：<font color="orange"><strong>左边或非门的输出是右边或非门的输入，而右边或非门的输出是左边或非门的输入。这种连接方式我们称之为反馈(feedback)。</strong></font>系统的输出返回给输入这种形式和我们在振荡器中讨论的情况很相似</p><p>初始情况下，两个输入都是0。当我们闭合上面的开关时，左边的或非门立刻输出0，右边的或非门输出也会变为1，这时灯泡被点亮。</p><p><img src="09.png"></p><p>但是当我们在打开上面的开关时，灯泡依然点亮。并且，无论我们怎么<strong>调整上面的开关</strong>灯泡依然点亮，究其原因可以发现这是由于左边或非门的输出一直为0。</p><p><img src="10.png"></p><p>当我们闭合下面的开关时，右边或非门的输入中有一个立刻变为1，其输出就相应地变为0，灯泡随之熄灭。左边或非门的输出此刻变为1。这时你再去断开下面的开关就会发现，灯泡一直处在熄灭状态。</p><p>在两个开关都断开的状态下，灯泡有时亮着，有时却不亮。<font color="orange">两个开关都断开时，电路有两个稳定态，这类电路统称为触发器(Flip-Flop)</font></p><p><strong>触发器电路可以保持信息，它可以“记住”某些信息</strong>。特别地，对于本章先前所讲述的触发器，<strong>它可以记住最近一次是哪个开关先闭合</strong>。如果你遇到这样一种触发器，如果它的灯泡是亮着的，你就可以推测出最后一次连通的是上面的开关；而如果灯泡不亮则可推测出最后一次连通的是下面的开关。</p><p><strong>它们可以让电路“记住”之前发生了什么事情。一个能计数的电路（本章后面要讲到）必定需要触发器。</strong></p><h3 id="r-sreset-set复位置位触发器"><a href="#R-S-Reset-Set，复位-置位-触发器" class="headerlink" title="R-S(Reset-Set，复位/置位)触发器"></a>R-S(Reset-Set，复位/置位)触发器</h3><p>我们通常把两个非或门绘制成另一种形式，加上标识符就得到了下面这幅图。</p><p><img src="12.png"></p><p>我们通常用Q来表示用于点亮灯泡的输出的状态。另一个输出 $\overline{Q}$（读做Q反）是对 Q 的取反。Q是0，$$\overline{Q}$$ 就是1，反之亦然。输入端S(Set)用来置位，R(Reset)用来复位。你可以把“置位”理解为把Q设为1，而“复位”是把Q设为0。当状态S为1时（对应于先前触发器中上面的开关闭合的情况），此时Q变为1而 $$\overline{Q}$$ 变为0；当R状态为1时（对应于前面图中闭合下面的开关的情况），此时Q变为0而 $$\overline{Q}$$ 变为1。当S和R均为0时，输出保持Q原来的状态不变。我们把结论总结如下表所示。</p><table><thead><tr><th align="center">输入</th><th align="center"></th><th align="center">输出</th><th align="center"></th></tr></thead><tbody><tr><td align="center">S</td><td align="center">R</td><td align="center">Q</td><td align="center">$$\overline{Q}$$</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">Q</td><td align="center">$$\overline{Q}$$</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">禁止</td><td align="center">禁止</td></tr></tbody></table><p>如果S、R状态同时为1时，Q和 $$\overline{Q}$$ 均会为零，这与Q和 $$\overline{Q}$$ 互反的假设关系相矛盾。所以当使用R-S触发器进行电路设计时，R、S输入同时为1的情况一定要避免。</p><p>R-S触发器可以简化为带有输入和输出标志的小框图，就像下面画的这样</p><p><img src="13.png"></p><p><font color="orange">R-S触发器最突出的特点在于，它可以记住哪个输入端的最终状态为1</font>。但是有时候我们需要一种记忆能力更加强大的电路，例如能记住在某个特定时间点上的一个信号是0还是1。</p><h3 id="d型触发器"><a href="#D型触发器" class="headerlink" title="D型触发器"></a>D型触发器</h3><p>在构造具备这种功能的电路之前，让我们先来思考一下它的具体行为。这个电路存在两个输入。其中一个我们称之为数据端(Data)。与所有数字信号一样，数据端取值为0或1；另一个输入被称为保持位(Hold That Bit)，保持位的作用就是使当前的状态被“记住”，通常情况下保持位被设置为0，在这种情况下数据端对电路不产生影响。当保持位置1时，数据端的值就会在电路系统中被“记住”。随后保持位又置为0，这时电路已经“记住”了数据端的最后一次输入，而之后数据端的输入无论如何变化都不会对电路产生影响。</p><p>我们可以把状态转化的过程以真值表的形式表示如下。</p><table><thead><tr><th align="center">输入</th><th align="center"></th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">数据</td><td align="center">保持位</td><td align="center">Q</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">X</td><td align="center">0</td><td align="center">Q</td></tr></tbody></table><p>X表示“其取值情况与结果无关”，只要保持位的值为0，那么数据位对电路的输出没有影响，电路的输出和其前一个状态相同</p><p>我们的电路需要在输入端增加两个与门，下图所给出了该系统的实现电路。</p><p><img src="14.png"></p><p>当保持位信号为1时，这套电路系统就和先前讲过的R-S触发器功能一致。</p><p>但我们需要改造一下这个触发器，我们只想要两个输入，而非三个输入。真正有意义的输入可以是S为0, R为1或者是R为0, S为1的情形。如果把数据端信号看做置位信号，把它取反后的值看做复位端信号，我们可以画出相应的电路图如下所示。</p><p><img src="15.png"></p><p>这个电路称为电平触发的D型触发器，D(Data)表示数据端输入。所谓电平触发是指当保持位输入为某一特定电平（本例中为“1”）时，触发器才保存数据端的输入值（很快，我们将看到另一种形式的触发器）</p><h3 id="电平触发的d型锁存器"><a href="#电平触发的D型锁存器" class="headerlink" title="电平触发的D型锁存器"></a>电平触发的D型锁存器</h3><p>通常情况下，输入端不会被标记为保持为，而是被标记为时钟（clock）。现在这个时钟仅仅用来指示什么时候保存数据。</p><p><img src="16.png"></p><p>通常把数据端简写为D，时钟端简写为Clk，其功能表如下所示。</p><p><img src="17.png"></p><p>这个电路也就是所谓的电平触发的D型锁存器，它表示电路锁存住一位数据并保持它，以便将来使用。这个电路也可以被称为1位存储器。</p><p>我们在一个小盒子里布置8个锁存器，如前所述，每个锁存器包括两个或非门、两个与门以及一个反相器。所有的时钟输入端都互相连在一起。结果如下图所示。</p><p><img src="18.png"></p><p>这个锁存器可以一次保存8位数。上面的8个输入端依次标记为D0～D7，下面的8个输出端被标记为Q0～Q7。左边的输入是时钟(Clk)，时钟信号通常为0。当时钟信号为1时，D端输入的8位值被送到Q端输出。当时钟信号为0时，这8位值将保持不变，直到时钟信号再次被置1。</p><p>也可以将8位锁存器的8个数据输入端和8个Q输出端画为两组线，如下图所示</p><p><img src="19.png"></p><p>我们可以改进我们的加法器（暂不考虑减法），8位加法器的8个S输出端既与灯泡相连，又连接到8位锁存器的数据(D)输入端。标记为“保存”(Save)的开关是锁存器的时钟输入，用来存放加法器的运算结果。</p><p><img src="20.png"></p><p>改进后的加法器包含了8个2-1选择器。但是加法器不能很好地处理进位输出(CO)信号。如果两个数的相加使得进位输出信号为1，那么当下个数被加进来的时候，这个信号将被忽略掉。一个可能的解决方案是将加法器、锁存器、选择器均设置为16位宽，或者至少应该比你可能遇到的最大的和的位数多一位。这个问题留到第17章具体讲述。</p><p>对于加法器而言，我们有一个更好的改进方法，就是去掉一整排的8个开关。但是我们需要先对D触发器做一些修改，为它加一个或门和一个称为清零(Clear)的输入信号。清零信号通常为0，但当它为1时，Q输出为0，如下图所示。</p><p><img src="21.png"></p><p>无论其他信号是什么，清零信号总是强制使Q输出为0，以达到使触发器清零的目的。</p><p><font color="orange">注意，标识为“相加”(Add)的开关现在控制着锁存器的时钟输入。</font></p><p>你可能会发现这个加法器比前面的那个好用，特别是当你需要加上一长串数字时。首先按下清零开关，这个操作会使锁存器的输出为0，并且熄灭了所有的灯泡，同时使8位加法器的第2行输入全为0。然后，通过开关输入第一个加数，并且闭合“相加”开关，这个加数的值就反映在灯泡上。再输入第二个加数并再次闭合“相加”开关。由开关输入的8位操作数加到前面的结果上，所得的和体现到灯泡上。反复如此操作，可以连续进行很多次加运算。</p><p><img src="22.png"></p><h3 id="边沿触发器edge-triggered"><a href="#边沿触发器（edge-triggered）" class="headerlink" title="边沿触发器（edge-triggered）"></a>边沿触发器（edge-triggered）</h3><p>某些应用而言，电平触发时钟输入已经足够用了；但是对另外一些应用来说，边沿触发(edge-triggered)时钟输入则更有效。<font color="orange"><strong>对于边沿触发器而言，只有当时钟从0跳变到1时，才会引起输出的改变。</strong></font>它们的区别在于，在电平触发器中，当时钟输入为0时，数据端输入的任何改变都不会影响输出；而在边沿触发器中，当时钟输入为1时，数据端输入的改变也不会影响输出。只有在时钟输入从0变到1的瞬间，数据端的输入才会影响边沿触发器的输出。</p><p>边沿触发的D型触发器是由两级R-S触发器按如下方式连接而成的。<font color="orange"><strong>只有当时钟信号由0变为1时，数据端输入才被保存下来。</strong></font></p><p>下图为一个处于非工作状态的触发器，其数据输入和时钟输入均为0，且Q输出也为0。</p><p><img src="23.png"></p><p>边沿触发的D型触发器的功能表需要一个新的符号来表示从0到1的瞬时变化，即用一个向上的箭头(↑)表示，如下表所示</p><p><img src="24.png"></p><p>中箭头表示当时钟端由0变为1时（称为时钟信号的“正跳变”，“负跳变”是指从1变为0），Q端输出与数据端输入是相同的。触发器的符号如下图所示。</p><p><img src="25.png"></p><p>书中把各种情况都罗列了一遍，（这里不再贴出所有的情况了，可以自己推，或者回去看本书P177）但是少了当时钟从1变成0的情况，我画了一个图，如下</p><p><img src="26.png"></p><h3 id="分频器frequency-divider"><a href="#分频器（frequency-divider）" class="headerlink" title="分频器（frequency divider）"></a>分频器（frequency divider）</h3><p>把振荡器的输出与边沿触发的D型触发器的时钟端输入连接，同时把 <strong>Q非</strong> 端输出连接到本身的D输入端</p><p><img src="27.png"></p><p>可以看出这个触发器的输出同时是他的输入。也就是一直重复反馈。（实际上，这种构造可能是有问题的，振荡器是由状态来回迅速改变的继电器构成的，其输出与构成触发器的继电器相连，而这些其他的继电器不一定能跟得上振荡器的速度。为了避免这些问题，这里假设振荡器中的继电器比电路中其他地方的继电器速度要慢得多）</p><p>让我们根据这个触发器，来模拟一下他的结构。</p><ol><li>当D端为1，Clk为0，输出的Q为0，Q非为1</li><li>当D端为1，Clk瞬时从0变成1时，输出的Q为1，Q非为0</li><li>当D端为0，Clk变为1时，输出的Q为1，Q非为0</li><li>当D端为0，Clk降为0时，输出的Q依然为1，Q非为0</li><li>当D端为0，Clk再次瞬时从0变成1时，输出的Q为0，Q非为1</li><li>当D端为1，Clk保持为1时，输出的Q保持为0，Q非为1</li></ol><p>如下图所示</p><p><img src="28.png"></p><p>以上发生的现象可以简单总结为：每当时钟输入由0变为1时，Q端输出就发生变化，或者从0到1，或者由1到0。下面的时序图可以更加清楚地说明这个问题。</p><p><img src="29.png"></p><p>从这个时序图中我们可以看出，<strong>一个时钟周期就是Q的一次变化</strong>。如果这个振荡器的频率为20Hz（即20个周期的时间为1s），那么Q的输出频率为它的一半，即10Hz，由于这个原因，这种电路称为<strong>分频器(frequency divider)</strong></p><p>试想一下，如果我们把三个分频器连接在一起，分频器的输出作为另一个分频器Clk的输入，这将会使得后面的分频器会再一次分频。</p><p><img src="30.png"></p><p>上图顶部的4个信号变化规律如下图所示</p><p><img src="31.png"></p><p>如果我们将其旋转90°，会发现他们分别对应十进制的0~15</p><p><img src="32.png"></p><p><img src="33.png"></p><h3 id="行波计数器"><a href="#行波计数器" class="headerlink" title="行波计数器"></a>行波计数器</h3><p>如果我们把8个分频器连接在一起，就会得到一个8位行波计数器，每一个触发器的输出都是下一个触发器的时钟输入。</p><p><img src="34.png"></p><p>我们的行波计数器会有一些延迟，<strong>更先进的计数器是“并行（同步）计数器”，这种计数器的所有输出都是在同一个时刻改变的。我们暂且使用这种计数器</strong></p><p>这样一个计数器的时序图可以将8个输出分别表示出来，也可以将它们作为整体一起表示出来，如下图所示。</p><p><img src="35.png"></p><p>可以看出，时钟信号的每一个正跳变发生时，二进制编码都递增了1。</p><p>随着触发器功能的增加，它的结构也变得更加复杂，下面给出了一个带预置和清零功能的边沿型D触发器。</p><p><img src="36.png"></p><p><strong>通常情况下，预置和清零信号输入会覆盖时钟和数据端输入，且两个输入都为0，当预置信号为1时，Q变为1，Q非 变为0。当清零信号为1, Q变为0，Q非 变为1（同R-S触发器中的S和R输入端一样，预置和清零信号不能同时为1）。除此之外，该触发器工作原理是和普通边沿D触发器是一样的。</strong></p><p><img src="37.png"></p><p>电路图符号可以简单地用下图来代替。</p><p><img src="38.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章从蜂鸣器开始将反向器的输入输出互连，为我们引出了振荡器。再从振荡器的0和1规律变化，阐述了时钟的概念。</p><p>接着，我们通过两个或非门奇怪的互连方式（一端的输入，是或非门另一端的输出），制作了一个R-S触发器，它是一个最简单的计数的触发器了。</p><ol><li>当S为1，R为0时，Q为1，Q非为0</li><li>当S为0，R为1时，Q为0，Q非为1</li><li>当S与R同时为0时，Q与Q非会保持上一次的状态</li><li>而S与R同时为1，是非法的操作。</li></ol><p>R-S触发器最突出的特点就是，它可以记住哪个输入端的最终状态为1</p><p>我们发现，保持位为0时，数据为无论是何值，输出的Q都是前一个状态。我们为R-S触发器接上两个与门，并将数据端通过一个反向器连接到另一个与门上，实现了只有两个输入的情况。而后，我们将R-S触发器稍加改造，创造出了D触发器。</p><p>D触发器可以保存数据，将8个D触发器连接起来，我们将得到一个8位锁存器。 他可以一次保存8位数，再连接一个2-1选择器，它们可以适用于加法器的连加操作。</p><p>D触发器的特点是电平触发。如果让数据端的值保存在锁存器中，需要把时钟端的输入从0变成1，但是如果时钟端输入一直为1时，数据端的输入就可以改变，我们将得到不同的Q，这似乎不太稳定。</p><p>于是，我们制作了边缘触发器（两个R-S触发器连接在一起，时钟端同时控制两级R-S触发器），它能更精确的控制输入。只有时钟从0跳变为1的瞬间，输出才会引起改变。</p><p>如果，我们将边缘触发器的时钟端与振荡器相连接。我们发现，Q的输出频率只有振荡器的一半频率，这也就是分频器了。那如果我们再将3个分频器相连接呢？（每一个分频器的输出都是下一个分频器的输入）通过时序图我们发现，这样的电路拥有了二进制计数的功能，并且每一个分频器都是上一个分频器频率的一半。</p><p>最后，我们采用并行（同步）8位计数器（所有输出都是在同一个时刻），会导致时钟信号的每一次正跳变，都会使二进制编码递增1。</p><p>我们改进了边缘D触发器，为其加上了清零和预置的新功能。</p><ol><li>当Pre为1，Clr为0，D与Clk任意值，Q为1，Q非为0</li><li>当Pre为0，Clr为1，D与Clk任意值，Q为0，Q非为1</li><li>当Pre与Clr为0，D为0，Clk瞬时从0变成1时，Q为0，Q非为1</li><li>当Pre与Clr为0，D为1，Clk瞬时从0变成1时，Q为1，Q非为0</li><li>当Pre与Clr为0，D为任意值，Clk为0时，Q与Q非保存上一次状态</li><li>注意：Pre与Clr同时为1是非法的</li></ol><p>每一章都非常有意思，层层递进。</p>]]></content>
    
    
    <summary type="html">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;非常重要的一章内容，相对之前章节也要更难一些。可以参考b站视频辅助学习&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1oL411D77D?spm_id_from=333.788.videopod.sections&amp;vd_source=7edae3cd790e850cc7836ab5c5d9ac4b&quot;&gt;锁存器与触发器详解合集&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="编码——隐匿在计算机软硬件背后的语言" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>如何实现减法——求补器</title>
    <link href="http://example.com/2025/01/17/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%87%8F%E6%B3%95%E2%80%94%E2%80%94%E6%B1%82%E8%A1%A5%E5%99%A8/"/>
    <id>http://example.com/2025/01/17/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%87%8F%E6%B3%95%E2%80%94%E2%80%94%E6%B1%82%E8%A1%A5%E5%99%A8/</id>
    <published>2025-01-17T06:47:14.000Z</published>
    <updated>2025-01-19T03:54:41.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="改进加法器实现减法操作"><a href="#改进加法器，实现减法操作" class="headerlink" title="改进加法器，实现减法操作"></a>改进加法器，实现减法操作</h3><p>减法没有进位机制，而是使用到了借位。但是通过一连串逻辑电路实现借位机制比较麻烦，那么我们如何避免发生借位，而有能实现减法呢？</p><blockquote><p>例如：计算 253 - 176</p></blockquote><p>我们可以先加上1000，再减去1000来实现。但是1000-176还是有借位，于是我们可以拆分为999+1的形式。即：</p><blockquote><p>253 - 176 = 253 + (999 - 176) +1 - 1000 = 77</p></blockquote><p>其实上面这个例子就是在求补码，通过补码来计算减法</p><blockquote><p>两数相减=被减数 + 减数求补码</p></blockquote><span id="more"></span><p><strong>如果被减数小于减数呢？</strong></p><blockquote><p>例如：计算 176 - 253</p></blockquote><p>还是同样的操作，即：</p><blockquote><p>176 - 253 = 176 + (999 - 253) + 1 - 1000 = -77</p></blockquote><p>当然，在计算机中我们需要用二进制来表示他们，可以自行转换成二进制计算。需要注意的是我们目前没办法表示负数，所以二进制得到的结果为77，即 01001101</p><p>这样我们就能改进上一章的加法器了，<font color="orange"><strong>为了避免问题太复杂，这个新的加/减法器只执行减数小于被减数的减法操作，即结果为正数的操作。</strong></font></p><p>下图为我们之前的加法器：</p><p><img src="./01.png"></p><p>而<strong>新的加/减法器可以设计为当计算减法时：减数求反码，CI(进位输入)+1，得到补码的操作</strong>。当计算加法时：CI 为0，也不求减数的反码。</p><p>对于求反，我们可以使用8个反相器来实现。</p><p><img src="./02.png"></p><p>而当运行加法运算时，我们不希望反相器工作。所以，我们还需要改进下电路。通过八个异或门来代替反相器。</p><p>当计算减法时，“取反”输出信号1。当计算加法时，“取反”输出信号0。</p><p><img src="03.png"></p><p>回想一下异或门的工作方式，如下表所示。</p><table><thead><tr><th align="center">XOR</th><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>如果“取反”信号为1，则输出信号反置。例如，如果输入为01100001，输出则为10011110。</p><p>将8个异或门合并起来画成一个器件，称为求补器(Ones’ Complement)，如下所示</p><p><img src="04.png"></p><p>现在还需要我们的加/减法器的CO(进位输出)输出问题。</p><ol><li>当计算加法时，即出现上位溢出的情况，我们需要将CO位输出1，即计算结果大于255，该结果需要舍弃</li><li>当计算减法时。当被减数大于减数，我们可以正常得出结果。当被<strong>减数小于减数</strong>，我们的结果会出现下溢的情况，该结果也需要舍弃。</li></ol><p>所以我们需要一个异或门来实现。</p><br><p>将一个求补器，一个8位二进制加法器和一个异或门做如下连接。</p><p><img src="05.png"></p><p>注意，这里三个信号都标识为“SUB”，这就是加/减法转换开关。当该信号为0的时候，其进行的是加法运算，为1时进行的则是减法运算。在减法中，输入B（第二排开关）在送入加法器之前，需先通过求补电路进行取反。此外，在做减法时，我们通过设定CI（进位输入）为1来使得结果加1。而在加法中，求补电路将不起作用，且输入CI为0。</p><hr><p>我们可以试着模拟一下这个加/减法器。</p><ol><li><p>模拟计算：253 - 176</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">253</span>的二进制码是：<span class="number">1111</span> <span class="number">1101</span></span><br><span class="line"><span class="number">176</span>的二进制码是：<span class="number">1011</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line"><span class="number">253</span>的补码是：<span class="number">0000</span> <span class="number">0011</span></span><br><span class="line"><span class="number">176</span>的补码是：<span class="number">0101</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> B输入为<span class="number">176</span>，即<span class="number">1011</span> <span class="number">0000</span>。经过求补器后（求补器中的SUB输出为<span class="number">1</span>），为<span class="number">0100</span> <span class="number">1111</span></span><br><span class="line"><span class="number">2.</span> 在加法器中，CI为<span class="number">1</span>（SUB输出<span class="number">1</span>）。</span><br><span class="line">  即<span class="number">253</span>+<span class="number">176</span>的反码+<span class="number">1</span> = <span class="number">253</span> + <span class="number">176</span>的补码 = <span class="number">253</span> - <span class="number">176</span></span><br><span class="line"></span><br><span class="line"><span class="number">253</span> - <span class="number">176</span> = <span class="number">253</span> + <span class="number">176</span>的补码</span><br><span class="line">= <span class="number">1111</span> <span class="number">1101</span> + <span class="number">0101</span> <span class="number">0000</span></span><br><span class="line">= <span class="number">1</span> <span class="number">0100</span> <span class="number">1101</span> </span><br><span class="line"></span><br><span class="line">此时CO为<span class="number">1</span>，SUB为<span class="number">1</span>（减法为<span class="number">1</span>），经过异或门输出为<span class="number">0</span>。</span><br><span class="line">最后结果为：<span class="number">0100</span> <span class="number">1101</span>，即：<span class="number">77</span></span><br></pre></td></tr></table></figure></li><li><p>模拟计算：176 - 253</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">253</span>的二进制码是：<span class="number">1111</span> <span class="number">1101</span></span><br><span class="line"><span class="number">176</span>的二进制码是：<span class="number">1011</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line"><span class="number">253</span>的补码是：<span class="number">0000</span> <span class="number">0011</span></span><br><span class="line"><span class="number">176</span>的补码是：<span class="number">0101</span> <span class="number">0000</span></span><br><span class="line">  </span><br><span class="line"><span class="number">1.</span> A输入为<span class="number">176</span>，即：<span class="number">1011</span> <span class="number">0000</span>。B输入为<span class="number">253</span>，即：<span class="number">1111</span> <span class="number">1101</span></span><br><span class="line"><span class="number">2.</span> 减法运算，SUB输出<span class="number">1</span>，对B求反码。即：<span class="number">0000</span> <span class="number">0010.</span></span><br><span class="line"><span class="number">3.</span> <span class="number">8</span>位加法器中，SUB输出为<span class="number">1</span>，即CI为<span class="number">1</span>，<span class="number">176</span>+<span class="number">253</span>的反码+<span class="number">1</span>。</span><br><span class="line">  即<span class="number">176</span>+<span class="number">253</span>的补码 = <span class="number">1011</span> <span class="number">0000</span> + <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">  = <span class="number">1011</span> <span class="number">0011</span> = <span class="number">128</span>+<span class="number">77</span> = <span class="number">205</span></span><br><span class="line"><span class="number">4.</span> CO为<span class="number">0</span>，SUB为<span class="number">1</span>，经过XOR后，结果为<span class="number">1</span>，出现下溢。舍弃当前结果</span><br></pre></td></tr></table></figure></li></ol><h3 id="如何表示负数"><a href="#如何表示负数" class="headerlink" title="如何表示负数"></a>如何表示负数</h3><p>详细内容可以看原文，这里只简单介绍</p><p>在8位二进制中，我们可以用1开头来表示负数。</p><p><font color="orange">对于无符号的8位二进制数，表示的范围为：0 ~ 255。对于有符号的二进制数表示的范围为：-128 ~ 127</font></p><table><thead><tr><th align="center">二进制数</th><th align="center">十进制数</th></tr></thead><tbody><tr><td align="center">1000 0000</td><td align="center">-128</td></tr><tr><td align="center">1000 0001</td><td align="center">-127</td></tr><tr><td align="center">1000 0010</td><td align="center">-126</td></tr><tr><td align="center">1000 0011</td><td align="center">-125</td></tr><tr><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">1111 1101</td><td align="center">-3</td></tr><tr><td align="center">1111 1110</td><td align="center">-2</td></tr><tr><td align="center">1111 1111</td><td align="center">-1</td></tr><tr><td align="center">0000 0000</td><td align="center">0</td></tr><tr><td align="center">0000 0001</td><td align="center">1</td></tr><tr><td align="center">0000 0002</td><td align="center">2</td></tr><tr><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">0111 1100</td><td align="center">124</td></tr><tr><td align="center">0111 1101</td><td align="center">125</td></tr><tr><td align="center">0111 1110</td><td align="center">126</td></tr><tr><td align="center">0111 1111</td><td align="center">127</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;改进加法器，实现减法操作&quot;&gt;&lt;a href=&quot;#改进加法器，实现减法操作&quot; class=&quot;headerlink&quot; title=&quot;改进加法器，实现减法操作&quot;&gt;&lt;/a&gt;改进加法器，实现减法操作&lt;/h3&gt;&lt;p&gt;减法没有进位机制，而是使用到了借位。但是通过一连串逻辑电路实现借位机制比较麻烦，那么我们如何避免发生借位，而有能实现减法呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如：计算 253 - 176&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以先加上1000，再减去1000来实现。但是1000-176还是有借位，于是我们可以拆分为999+1的形式。即：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;253 - 176 = 253 + (999 - 176) +1 - 1000 = 77&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实上面这个例子就是在求补码，通过补码来计算减法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两数相减=被减数 + 减数求补码&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="编码——隐匿在计算机软硬件背后的语言" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>二进制加法器</title>
    <link href="http://example.com/2025/01/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%99%A8/"/>
    <id>http://example.com/2025/01/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%99%A8/</id>
    <published>2025-01-14T03:57:33.000Z</published>
    <updated>2025-01-28T11:55:21.091Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>关于《编码——隐匿在计算机软硬件背后的语言》这本书的一些小笔记</p><p>图片比较大，img标签有点麻烦了，谁能给我写个js哈哈哈🤦🏻‍♀️</p><p>拓展阅读：<a href="https://github.com/test-wsl/Computer-Organization/blob/master/Computer-Organization.md">https://github.com/test-wsl/Computer-Organization/blob/master/Computer-Organization.md</a></p><span id="more"></span><h3 id="二进制加法器"><a href="#二进制加法器" class="headerlink" title="二进制加法器"></a>二进制加法器</h3><p>为了实现加法器，两数操作即如下图：</p><p><img src="01.png"></p><p>我们需要一个或门和一个与非门的输出，并将结果用一个与门连接起来，这样我们就得到了两数相加的正确结果</p><p><img src="02.png"></p><p><img src="03.png"></p><p>这个电路有一个专门的名字：异或门，简称：XOR</p><table><thead><tr><th>XOR</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>它的符号为</p><p><img src="04.png"></p><p>当我们把异或门和进位电路（与门）连在一起时就得到了一个半加器</p><p><img src="05.png"></p><p>为了简化，我们将其画成如下形式</p><p><img src="06.png"></p><p>之所以叫半加器，是因为它只能做两个数相加的操作，无法将进位数加入其中进行运算。也是由其物理特性决定，只有两个输入位，以及加和输出和进位输出。</p><p>为了对三个二进制数进行加法运算，我们需要将两个半加器和一个或门做如下连接。</p><p><img src="07.png"></p><p>简化图形如下：</p><p><img src="08.png"></p><p>下面，我们将8个全加器连接起来，每个全加器的进位输出都作为下一个全加器的进位输入</p><p><img src="09.png"></p><p>下面画成一个盒子的完整的8位二进制加法器，输入标记为A<del>0</del> ~ A<del>7</del>和B<del>0</del> ~ B<del>7</del>，输出标记为S<del>0</del> ~ S<del>7</del></p><p><img src="10.png"></p><p><font color="orange">其中A<del>0</del>、B<del>0</del>、S<del>0</del> 都是最低有效位，而A<del>7</del>、B<del>7</del>、S<del>7</del>都是最高有效位</font></p><p>如果把下面一排的每个二进制位和其对应的2的幂相乘再依次相加，你就会得到0110-1001的十进制数表示64+32+8+1，即105。</p><p>当然，我们也可以把8位加法器用下图表示</p><p><img src="11.png"></p><p>一旦你搭建起了8位二进制加法器，你就可以再搭建另外一个加法器。把它们级联起来就可以很容易地扩展出一个16位加法器。</p><p><img src="12.png"></p><p>回顾一下我们所有学过的加法器：</p><p><img src="13.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于《编码——隐匿在计算机软硬件背后的语言》这本书的一些小笔记&lt;/p&gt;
&lt;p&gt;图片比较大，img标签有点麻烦了，谁能给我写个js哈哈哈🤦🏻‍♀️&lt;/p&gt;
&lt;p&gt;拓展阅读：&lt;a href=&quot;https://github.com/test-wsl/Computer-Organization/blob/master/Computer-Organization.md&quot;&gt;https://github.com/test-wsl/Computer-Organization/blob/master/Computer-Organization.md&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="编码——隐匿在计算机软硬件背后的语言" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>构建之法——00.概论</title>
    <link href="http://example.com/2025/01/09/%E6%9E%84%E5%BB%BA%E4%B9%8B%E6%B3%95%E2%80%94%E2%80%9400-%E6%A6%82%E8%AE%BA/"/>
    <id>http://example.com/2025/01/09/%E6%9E%84%E5%BB%BA%E4%B9%8B%E6%B3%95%E2%80%94%E2%80%9400-%E6%A6%82%E8%AE%BA/</id>
    <published>2025-01-09T10:57:41.000Z</published>
    <updated>2025-01-09T11:49:45.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近试读《构建之法—现代软件工程》这本书，不知道有没有时间能看完，也不知道有没有时间能写完这本书的笔记，先记录下来吧</p><h3><span id="软件程序软件工程">软件=程序+软件工程</span></h3><p>作者通过一个很生动的实际需求例子，为我们引入了软件工程的概念。基于“<code>程序=数据结构+算法</code>”的这句名言，作者通过这个例子，给了我们两个推论：</p><center><strong>软件 = 程序 + 软件工程</strong></center><p>正式因为有了构建管理、源代码管理、软件设计、软件测试、项目管理这些软件工程的内容，才能把程序转化成一个可靠的软件。</p><center><strong>软件企业 = 软件 + 商业模式</strong></center><span id="more"></span><h4><span id="软件开发的不同阶段">软件开发的不同阶段</span></h4><p>“软件工程”自1968年被首次提出后，经历了不同的发展阶段。</p><p>作者用航空产业的阶段为我们做了一次类比：</p><ol><li>玩具阶段</li><li>业余爱好者阶段</li><li>探索阶段</li><li>成熟的产业阶段</li></ol><p>在成熟的航空工业中，一个飞机发动机从构思到最后运行，不知道要经历多少人、多少工序、多少流程、多少相关知识的验证，其实一款大型软件的开发同样如此。</p><h3><span id="软件工程是什么">软件工程是什么</span></h3><p>软件工程是把系统的、有序的、可量化的方法应用到软件的开发、运营和维护上的过程</p><p>软件工程包括下列领域：软件需求分析、软件设计、软件构建、软件测试和软件维护</p><p>软件工程和下列的学科相关：计算机科学、计算机工程、管理学、数学、项目管理学、质量管理、软件人体工学、系统工程、工业设计和用户体验设计</p><h4><span id="软件开发的难点">软件开发的难点</span></h4><ol><li><strong>复杂性（Complexity）</strong></li><li><strong>不可见性（Invisibility）</strong>：软件如何运行，bug难以排查</li><li><strong>易变性（Changeability）</strong>：用户需求不断变更，还要保证软件正常稳定运行</li><li><strong>服从性（Conformity）</strong>：软件不仅要服从操作系统、硬件、还要考虑到用户需求以及行业系统要求</li><li><strong>非连续性（Discontinuity）</strong>：软件的行为或结果对某些输入或环境条件的微小变化非常敏感，可能导致显著的输出变化或系统行为的重大改变</li></ol><h4><span id="软件工程与计算机科学的关系">软件工程与计算机科学的关系</span></h4><p>很多学校开设了软件工程专业以及计算机科学与技术专业，但他们的区别很多人都不太清楚。简单来说他们是理论与实践的关系</p><p><img src="./00/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BE%A7%E9%87%8D%E7%82%B9.png" alt="计算机科学与软件工程侧重点不同"></p><h4><span id="软件工程的知识领域">软件工程的知识领域</span></h4><ol><li><p><strong>Software Requirements</strong> - <strong>软件需求</strong></p></li><li><p><strong>Software Design</strong> - <strong>软件设计</strong></p></li><li><p><strong>Software Construction</strong> - <strong>软件构建</strong></p></li><li><p><strong>Software Testing</strong> - <strong>软件测试</strong></p></li><li><p><strong>Software Maintenance</strong> - <strong>软件维护</strong></p></li><li><p><strong>Software Configuration Management</strong> - <strong>软件配置管理</strong></p></li><li><p><strong>Software Engineering Management</strong> - <strong>软件工程管理</strong></p></li><li><p><strong>Software Engineering Process</strong> - <strong>软件工程过程</strong></p></li><li><p><strong>Software Engineering Models and Methods</strong> - <strong>软件工程模型与方法</strong></p></li><li><p><strong>Software Quality</strong> - <strong>软件质量</strong></p></li><li><p><strong>Software Engineering Professional Practice</strong> - <strong>软件工程职业实践</strong></p></li><li><p><strong>Software Engineering Economics</strong> - <strong>软件工程经济学</strong></p></li><li><p><strong>Computing Foundations</strong> - <strong>计算基础</strong></p></li><li><p><strong>Mathematical Foundations</strong> - <strong>数学基础</strong></p></li><li><p><strong>Engineering Foundations</strong> - <strong>工程基础</strong></p></li></ol><h4><span id="软件工程的目标创建足够好的软件">软件工程的目标——创建“足够好”的软件</span></h4><ol><li>用户满意度高</li><li>可靠</li><li>软件流程质量高</li><li>可维护</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近试读《构建之法—现代软件工程》这本书，不知道有没有时间能看完，也不知道有没有时间能写完这本书的笔记，先记录下来吧&lt;/p&gt;
&lt;h3 id=&quot;软件-程序-软件工程&quot;&gt;&lt;a href=&quot;#软件-程序-软件工程&quot; class=&quot;headerlink&quot; title=&quot;软件=程序+软件工程&quot;&gt;&lt;/a&gt;软件=程序+软件工程&lt;/h3&gt;&lt;p&gt;作者通过一个很生动的实际需求例子，为我们引入了软件工程的概念。基于“&lt;code&gt;程序=数据结构+算法&lt;/code&gt;”的这句名言，作者通过这个例子，给了我们两个推论：&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;软件 = 程序 + 软件工程&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;正式因为有了构建管理、源代码管理、软件设计、软件测试、项目管理这些软件工程的内容，才能把程序转化成一个可靠的软件。&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;软件企业 = 软件 + 商业模式&lt;/strong&gt;&lt;/center&gt;</summary>
    
    
    
    
    <category term="构建之法" scheme="http://example.com/tags/%E6%9E%84%E5%BB%BA%E4%B9%8B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>何必缅怀</title>
    <link href="http://example.com/2025/01/09/%E4%BD%95%E5%BF%85%E7%BC%85%E6%80%80/"/>
    <id>http://example.com/2025/01/09/%E4%BD%95%E5%BF%85%E7%BC%85%E6%80%80/</id>
    <published>2025-01-09T06:10:46.000Z</published>
    <updated>2025-01-09T06:28:17.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近看到一位up在自己的blog上更新日常，那些枯燥的文章，或许也需要一些随笔的润色吧。</p><p>但，我希望我的内容没有人能看见，仅仅是记录生活而已。</p><span id="more"></span>    <div id="aplayer-RjsegcgX" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="16951277" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div><p><small><center>这首歌只能试听…</center></small></p><hr><p>我发现自从我只关注自我后，好像变得有点自私和素质低下了[捂脸]。对很多身边的事情也变得无所谓起来，不凑热闹，也不参与讨论，任凭命运摆布。对看不惯的人也说起了脏字，这在以前可以说从未有过</p><p>我妈妈也是这样的人，她有了自己的事业后，对于不懂她的我爸，有时候也会带一些脏字，虽然这种情况很少出现，但在我的记忆中，从来没有</p><p>今天，做了两个奇怪的梦。两个都是老生常谈的恐惧。一个是新样式的中式恐怖，还是追逐，我一如既往的逃跑，醒来后，当阳光透过窗纱，照亮我的房间，一切烟消云散，不再记得了。</p><p>另一个是怅然若失的瞬间。我梦见，我和大学室友一起去了济南。我抛下他们，与游客们一同等待，在傍晚无光的日落时分，等待一个绚丽的开场。没有得到想要的照片，当我再回头寻找，他们已不在我身旁。这一切并不难以预料，心中的失落在所难免，只得独自坐上火车离开这里。</p><p>回到寝室，已然是黄昏之时。阳光透过窗帘，为寝室添上了一层暖色。我站在窗前，看着少坤，穿着还未来得及撕下价签的西装，看见躺在被窝里有说有笑的朱和亚亚。他们好像都有着自己已定的生活轨迹与目标，看着他们，内心却难免有些失落。</p><p>大学其实是一段美好的时光，不知为何在梦中也添上了一层薄薄的雾霭。从前的梦，总是回到高中，回到考场，回到被挨骂的瞬间。从前，我一直想拯救那个时候的自己，从前，我一直想如果我能回到过去，我想拯救那个无助的自己。</p><p>可现在我并不想回到过去，他如何如何，好像与我无关。我只是静待命运到来，如同对待他人一般。</p><p>人生好像总是充满了遗憾与未知。不管当下拥有了何总资源，又站在了何种高度，总是会回想从前，总是在回望过去，总是在迷惘中不断徘徊，总是做着相同的梦。</p><p>如同以往，晨曦洒满房间。静静呆坐，回望自己。</p><p>end.</p><hr><p>我把这些都说给了一个朋友，他很有耐心的看完，或许是时机不对，他不想当情绪的垃圾桶，无可厚非。生活的压力何其重啊，向来不缺苦难与忧伤，不然短视频也不会那么爆火，需要它来麻痹神经，去碰浅显的快乐。</p><p>回想起来，自己有何尝不是如此。或许当有人能把苦难分享给你，也是对你的认可吧，但其实说起来也无足轻重啦，请过好自己的人生。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看到一位up在自己的blog上更新日常，那些枯燥的文章，或许也需要一些随笔的润色吧。&lt;/p&gt;
&lt;p&gt;但，我希望我的内容没有人能看见，仅仅是记录生活而已。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="2025" scheme="http://example.com/tags/2025/"/>
    
  </entry>
  
  <entry>
    <title>2024年终总结</title>
    <link href="http://example.com/2025/01/02/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2025/01/02/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2025-01-02T04:14:34.000Z</published>
    <updated>2025-01-02T07:02:46.709Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-ScZYpSwJ" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="504025917" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div><br><p>回忆如潮水，过往似流波。</p><p>时常发呆，内心似死水，思绪毫无尽头。还是会梦见高中生活，惊恐万分而又怅然若失。还是会羡慕美好的爱情，可友情，亲情与爱情，纯粹的渴望，或许那只是一个乌托邦。</p><p>我所能看见的便是冷漠——我的冷漠。独行于世界之外，自私而又没有礼貌，在自我搭建的幻梦中，躲避着一切。</p><p>越是成长，道德边界与底线也越是模糊不清。关于人性的复杂争论永无休止，毫无头绪。</p><p>这一年谈论其他都有些虚假，能写下的也仅此而已。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="2024" scheme="http://example.com/tags/2024/"/>
    
  </entry>
  
  <entry>
    <title>穆旦诗集</title>
    <link href="http://example.com/2024/06/20/%E7%A9%86%E6%97%A6%E8%AF%97%E9%9B%86/"/>
    <id>http://example.com/2024/06/20/%E7%A9%86%E6%97%A6%E8%AF%97%E9%9B%86/</id>
    <published>2024-06-20T14:35:57.000Z</published>
    <updated>2024-06-20T15:26:19.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>穆旦诗集部分摘抄，或许找个时间能给通读一遍呢？</p><br><h4><span id="诗八首节选">《诗八首——节选》</span></h4><p>风暴，远路，寂寞的夜晚，</p><p>丢失，记忆，永续的时间，</p><p>所有科学不能祛除的恐惧</p><p>让我在你的怀里得到安憩</p><br><span id="more"></span><h4><span id="冥想">《冥想》</span></h4><p>1</p><p>为什么万物之灵的我们，</p><p> 遭遇还比不上一棵小树？</p><p> 今天你摇摇它，优越地微笑，</p><p> 明天就化为根下的泥土。</p><p> 为什么由手写出的这些字， </p><p>竟比这只手更长久，健壮？</p><p> 它们会把腐烂的手抛开，</p><p> 而默默生存在一张破纸上。</p><p>因此，我傲然生活了几十年，</p><p>仿佛曾做着万物的导演，</p><p>实则在它们长久的秩序下</p><p>我只当一会小小的演员。  </p><p>2</p><p>把生命的突泉捧在我手里，</p><p>我只觉得它来得新鲜，</p><p>是浓烈的酒，清新的泡沫</p><p>注入我的奔波、劳作、冒险。</p><p>仿佛前人从未经临的园地</p><p>就要展现在我的面前。</p><p>但如今，突然面对着坟墓，</p><p>我冷眼向过去稍稍回顾，</p><p>只见它曲折灌溉的悲喜</p><p>都消失在一片亘古的荒漠， </p><p>这才知道我的全部努力</p><p>不过完成了普通的生活。</p><br><h4><span id="园">《园》</span></h4><p>从温馨的泥土里伸出来的 </p><p>以嫩枝举在高空中的树丛， </p><p>沐浴着转移的金色的阳光。</p><p>水彩未干的深蓝的天穹 </p><p>紧接着蔓绿的低矮的石墙， </p><p>静静兜住了一个凉夏的清晨。</p><p>全都盛在这小小的方圆中： </p><p>那沾有雨意的白色卷云， </p><p>远栖于西山下的烦嚣小城。</p><p>如同我匆匆地来又匆匆而去， </p><p>躲在密叶里的陌生的燕子 </p><p>永远鸣啭着同样的歌声。</p><p>当我踏出这芜杂的门径， </p><p>关在里面的是过去的日子， </p><p>青草样的忧郁，红花样的青春。</p><br><h4><span id="森林之魅祭胡康河上的白骨">《森林之魅——祭胡康河上的白骨》</span></h4><p>穆旦的《森林之魅——祭胡康河上的白骨》是一首现代诗，创作于1946年。这首诗是穆旦以自身参加远征军并亲身经历”滇缅大撤退”后的深刻印象所作，抒发了诗人强烈的情感。诗中，穆旦通过对森林的拟人化描述，展现了一种原始、野性而又神秘的力量，同时也表达了对逝去生命的哀悼和对战争残酷的反思。</p><p>《森林之魅》这首诗通过戏剧化的表达手法，构建了人与森林之间的对话，揭示了自然与人类之间复杂的关系。森林在诗中既是生命的源泉，又是死亡的象征，它以一种几乎诱惑的方式，欢迎人类的到来，却又在无形中吞噬着人类的生命。诗中的”人”则代表了那些在战争中逝去的战士，他们在森林中经历了极端的饥饿、疾病和绝望，最终成为了森林的一部分。</p><p>这首诗不仅是对胡康河谷战役中牺牲烈士的纪念，也是对战争、生命和自然的深刻思考。穆旦以其独特的文学才华，将个人经历与广阔的历史背景相结合，创作出了这首充满力量和深度的诗歌作品。</p><br><p><strong>森林：</strong></p><p>没有人知道我，我站在世界的一方。</p><p>我的容量大如海，随微风而起舞，</p><p>张开绿色肥大的叶子，我的牙齿。</p><p>没有人看见我笑，我笑而无声，</p><p>我又自己倒下来，长久的腐烂，</p><p>仍旧是滋养了自己的内心。</p><p>从山坡到河谷，从河谷到群山，</p><p>仙子早死去，人也不再来，</p><p>那幽深的小径埋在榛莽下，</p><p>我出自原始，重把秘密的原始展开</p><p>那毒烈的太阳，那深厚的雨，</p><p>那飘来飘去的白云在我头顶，</p><p>全不过来遮盖，多种掩盖下的我</p><p>是一个生命，隐藏而不能移动。</p><p><strong>人：</strong></p><p>离开文明，是离开了众多的敌人，</p><p>在青苔藤蔓间，在百年的枯叶上，</p><p>死去了世间的声音。这青青杂草，</p><p>这红色小花，和花丛里的嗡营，</p><p>这不知名的虫类，爬行或飞走，</p><p>和跳跃的猿鸣，鸟叫，和水中的</p><p>游鱼，蟒和象和更大的畏惧，</p><p>以自然之名，全得到自然的崇奉，</p><p>无始无终，窒息在难懂的梦里，</p><p>我不合谐的旅程把一切惊动。</p><p><strong>森林：</strong></p><p>欢迎你来，把血肉脱尽。</p><p><strong>人：</strong></p><p>是什么声音呼唤？有什么东西</p><p>忽然躲避我？在绿叶后面</p><p>它露出眼睛，向我注视，我移动</p><p>它轻轻跟随。黑夜带来它嫉妒的沉默</p><p>贴近我全身。而树和树织成的网</p><p>压住我的呼吸，隔去我享有的天空！</p><p>是饥饿的空间，低语又飞旋，</p><p>像多智的灵魅，使我渐渐明白</p><p>它的要求温柔而邪恶，它散布</p><p>疾病和绝望，和憩静，要我依从。</p><p>在横倒的大树旁，在腐烂的叶上，</p><p>绿色的毒，你瘫患了我的血肉和深心！</p><p><strong>森林：</strong></p><p>这不过是我，设法朝你走近，</p><p>我要把你领过黑暗的门径；</p><p>美丽的一切，由我无形的掌握，</p><p>全在这一边，等你枯萎后来临。</p><p>美丽的将是你无目的眼，</p><p>一个梦去了，另一个梦来代替，</p><p>无言的牙齿，它有更好听的声音。</p><p>从此我们一起，在空幻的世界游走，</p><p>空幻的是所有你血液里的纷争；</p><p>一个长久的生命就要拥有你，</p><p>你的花，你的叶，你的幼虫。</p><p><strong>祭歌：</strong></p><p>在阴暗的树下，在急流的水边，</p><p>逝去的六月和七月，在无人的山间，</p><p>你们的身体还挣扎着想要回返，</p><p>而无名的野花已在头上开满。</p><p>那刻骨的饥饿，那山洪的冲激，</p><p>那毒虫的啮咬和痛楚的夜晚，</p><p>你们受不了要向人讲述，</p><p>如今却是欣欣的林木把一切遗忘。</p><p>过去的是你们对死的抗争，</p><p>你们死去为了要活的人们生存，</p><p>那白热的纷争还没有停止，</p><p>你们却在森林的周期内，不再听闻。</p><p>静静的，在那被遗忘的山坡上，</p><p>还下着密雨，还吹着细风，</p><p>没有人知道历史曾在此走过，</p><p>留下了英灵化入树干而滋生。</p><br><h4><span id="reference">Reference</span></h4><p>穆旦诗编年汇校</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;穆旦诗集部分摘抄，或许找个时间能给通读一遍呢？&lt;/p&gt;
&lt;br&gt;

&lt;h4 id=&quot;《诗八首——节选》&quot;&gt;&lt;a href=&quot;#《诗八首——节选》&quot; class=&quot;headerlink&quot; title=&quot;《诗八首——节选》&quot;&gt;&lt;/a&gt;《诗八首——节选》&lt;/h4&gt;&lt;p&gt;风暴，远路，寂寞的夜晚，&lt;/p&gt;
&lt;p&gt;丢失，记忆，永续的时间，&lt;/p&gt;
&lt;p&gt;所有科学不能祛除的恐惧&lt;/p&gt;
&lt;p&gt;让我在你的怀里得到安憩&lt;/p&gt;
&lt;br&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="2024" scheme="http://example.com/tags/2024/"/>
    
  </entry>
  
  <entry>
    <title>德米安-埃米尔·辛克莱的彷徨少年时</title>
    <link href="http://example.com/2024/05/27/%E5%BE%B7%E7%B1%B3%E5%AE%89-%E5%9F%83%E7%B1%B3%E5%B0%94%C2%B7%E8%BE%9B%E5%85%8B%E8%8E%B1%E7%9A%84%E5%BD%B7%E5%BE%A8%E5%B0%91%E5%B9%B4%E6%97%B6/"/>
    <id>http://example.com/2024/05/27/%E5%BE%B7%E7%B1%B3%E5%AE%89-%E5%9F%83%E7%B1%B3%E5%B0%94%C2%B7%E8%BE%9B%E5%85%8B%E8%8E%B1%E7%9A%84%E5%BD%B7%E5%BE%A8%E5%B0%91%E5%B9%B4%E6%97%B6/</id>
    <published>2024-05-26T16:43:55.000Z</published>
    <updated>2024-05-26T16:47:04.506Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>黑塞的书一如既往的难读啊…</p><p>去年的《悉达多》就只了解了个大概，今年的《德米安》依旧如此…</p><p>希望未来能有时间把它们重新再拾起来吧</p><blockquote><p>人的一生是自我寻觅的过程，在大大小小的路途上尝试并获得启示，没有人能得到完美的结局。然而，每个人都在朝着它努力，或愚笨或明晰，尽着自己的所能。我们无法摆脱自己出生的痕迹，身体背负着史前世界的黏液和蛋壳，直到永恒的终点。有些生命永远无法进化为人，它们止于青蛙、蜥蜴和蚂蚁，有的则人鱼各半。但我们都是自然之子，都在迈向人类的路途中，起源和母体一样，来自同一个黑洞，努力从生命深处爬向自己的目标。我们可以相互理解，但自我的诠释却只能亲力亲为。</p></blockquote><span id="more"></span><p>当你无法对抗与生俱来的荒蛮与动物性，也就无法进化成为人，止于青蛙、蜥蜴和蚂蚁</p><p>人性并非全然的善，这也是我们第一步需要认知到的问题，而书中与克罗莫的遭遇，就很好的诠释了这一点。即动物性与荒蛮性是人性所构成的一部分，当它被我们所深知之后，我们才能更好的追求文明，理性的意义也才被我们所深知——当你深知自身的黑暗之后，才能更好与之对抗</p><p>在当我连被克罗莫霸凌的事实都没勇气说出口时，德米安却悄无声息的帮我解决了这个问题</p><blockquote><p>“我先回家了。”他在雨中将大衣领子拉紧，说，“我只想再告诉你，事已至此，你必须摆脱这家伙！如果没别的办法，就打死他，那样我会对你刮目相看的。我也会帮你。”<br>我突然想到了该隐，感到很恐怖，开始轻轻啜泣。周围的世界太可怕。</p></blockquote><p>可悲的是这时的我连面对的勇气都没有，也无法承认世界的另一半黑暗，无法承认自身的欲望，无法驾驭自身的动物性，更无法辨认和使用。这在我儿时的生活中是不曾接触的，儿时的世界仅有善的一半。</p><blockquote><p>只要我们满心期盼，只要这个愿望真正萦回于我们全部的生命，我们就能拥有足够强大的意志去实施它。一旦如此，一旦人按照内心的命令去尝试，就能实现愿望，驾驭意志，宛如驾驭一匹良驹。</p></blockquote><p>只有我们自身的理性能力，我们的辨证思维能打败我们心中的克罗莫——我们的境界和我们的胸怀是需要向善的方式去完成的，但是我们的智慧和我们的坚强，却是需要有直面恶的力量去完成的</p><blockquote><p>有勇气和个性的人，在他人看来总是骇人。这种具备无畏又骇人特质的人四处行走，让人极为不适。于是人们给这种人起绰号，杜撰寓言。为了报复他们，也为稍许掩饰自己流露的恐惧——你懂吗？”</p><p>我认为，该隐是个卓越的人。人们因为怕他，才编出这种故事。这个故事是谣言，就像人们四处嚼舌的传闻。但有一点是真的，该隐和他的后裔的确携有某种‘记号’，有别于大多数人。”</p><p>我们拥有一个可以仰慕的上帝，但他只展示世界的一半——那个公开规矩的光明世界。而我们应该崇拜的是一个完整的世界，既是上帝也是魔鬼的神。阿布拉克萨斯就是这样一个神。</p></blockquote><p>我们需要的是听从内心理性的声音，去怀疑，去反思，而不是安逸的生活在上帝为我们打造美好的一半世界当中。当社会给予的一切规训，我们都温和的说是的，这都是对的。即用这些规训塑造自己、要求自己，而不去探讨这背后的真相，是否对我们具有其欺骗性和伤害。但那也许有另外一种真相呢！——你所信仰的这个善的世界可能只是一个谎言。</p><p>虽然我们能清楚的认知我们活在巨大的谎言之中，活在约的的欺骗之中，但又有多少人愿意走出来，愿意与之抗争呢？面对巨大的谎言，又如何得到内心的满足和自己想要的生活呢？</p><blockquote><p>飞鸟奋力欲破壳而出。蛋即世界。欲新生者必先摧毁世界。鸟儿飞向上帝，上帝之名是阿布拉克萨斯</p></blockquote><ul><li>感受痛苦</li><li>反思并质疑</li><li>抗拒与叛逆</li><li>打造属于自己的真正的自我世界</li></ul><p>当你无法感受痛苦也就不会反思，无法获得新生，即书中辛克莱在克莱莫事件中所感受到的痛苦，成为了我自救的第一步。</p><p>…待更新</p><p>Reference</p><blockquote><p><a href="https://space.bilibili.com/84102036/search/video?keyword=%E5%BE%B7%E7%B1%B3%E5%AE%89">杜素娟细读精典——德米安</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;黑塞的书一如既往的难读啊…&lt;/p&gt;
&lt;p&gt;去年的《悉达多》就只了解了个大概，今年的《德米安》依旧如此…&lt;/p&gt;
&lt;p&gt;希望未来能有时间把它们重新再拾起来吧&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人的一生是自我寻觅的过程，在大大小小的路途上尝试并获得启示，没有人能得到完美的结局。然而，每个人都在朝着它努力，或愚笨或明晰，尽着自己的所能。我们无法摆脱自己出生的痕迹，身体背负着史前世界的黏液和蛋壳，直到永恒的终点。有些生命永远无法进化为人，它们止于青蛙、蜥蜴和蚂蚁，有的则人鱼各半。但我们都是自然之子，都在迈向人类的路途中，起源和母体一样，来自同一个黑洞，努力从生命深处爬向自己的目标。我们可以相互理解，但自我的诠释却只能亲力亲为。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="书评" scheme="http://example.com/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
    <category term="2024" scheme="http://example.com/tags/2024/"/>
    
  </entry>
  
  <entry>
    <title>Python之常用设计模式</title>
    <link href="http://example.com/2024/05/03/Python%E4%B9%8B%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2024/05/03/Python%E4%B9%8B%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-05-03T14:24:30.000Z</published>
    <updated>2024-05-15T15:58:29.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3><span id="简单工厂设计模式">简单工厂设计模式</span></h3><p>内容：不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例</p><p>角色：</p><ul><li>抽象工厂角色（Creator）</li><li>具体工厂角色（Concrete Creator）</li><li>具体产品角色（Concrete Product）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Payment</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alipay</span>(<span class="params">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, use_huabei=<span class="literal">False</span></span>):</span></span><br><span class="line">        self.use_huabei = use_huabei</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.use_huabei:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;花呗支付%d元&quot;</span> % money)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;支付宝支付%d元&quot;</span> % money)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WechatPay</span>(<span class="params">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;微信支付%d元&quot;</span> % money)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankPay</span>(<span class="params">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;银行卡支付%d元&quot;</span> % money)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_payment</span>(<span class="params">self, method</span>):</span></span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">&#x27;alipay&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> Alipay(use_huabei=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">&#x27;wechat&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> WechatPay()</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">&#x27;bankpay&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> BankPay()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;No such payment named %s&quot;</span> % method)</span><br><span class="line">        </span><br><span class="line">pf = PaymentFactory()</span><br><span class="line">p = pf.create_payment(<span class="string">&#x27;alipay&#x27;</span>)</span><br><span class="line">p.pay(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><span id="more"></span><p>优点：</p><ul><li>隐藏了对象创建的实现细节</li><li>客户端不需要修改代码</li></ul><p>缺点：</p><ul><li>违反了单一职责原则，将创建逻辑几种到一个工厂类里</li><li>当添加新产品时，需要修改工厂类代码，违反了开闭原则</li></ul><h3><span id="工厂方法模式">工厂方法模式</span></h3><p>内容：定义一个用于创建对象的接口（工厂接口），让子类决定实例化那一个产品类</p><p>角色：</p><ul><li>抽象工厂角色（Creator）</li><li>具体工厂角色（Concrete Creator）</li><li>抽象产品角色（Product）</li><li>具体产品角色（Concrete Product）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义支付类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Payment</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alipay</span>(<span class="params">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, use_huabei=<span class="literal">False</span></span>):</span></span><br><span class="line">        self.use_huabei = use_huabei</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.use_huabei:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;花呗支付%d元&quot;</span> % money)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;支付宝支付%d元&quot;</span> % money)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WechatPay</span>(<span class="params">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;微信支付%d元&quot;</span> % money)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankPay</span>(<span class="params">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;银行卡支付%d元&quot;</span> % money)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentFactory</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_payment</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AliPayFactory</span>(<span class="params">PaymentFactory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_payment</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Alipay(use_huabei=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WechatPayFactory</span>(<span class="params">PaymentFactory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_payment</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> WechatPay()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankPayFactory</span>(<span class="params">PaymentFactory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_payment</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">pf = AliPayFactory()</span><br><span class="line">p = pf.create_payment()</span><br><span class="line">p.pay(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>每个具体产品都对应一个具体工厂类，不需要修改工厂类代码</li><li>隐藏了对象创建的实现细节</li></ul><p>缺点：</p><ul><li>每增加一个具体产品类，就必须增加一个相对应的具体工厂类</li></ul><h3><span id="抽象工厂模式">抽象工厂模式</span></h3><p>内容：定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖的对象</p><p>例如：生产一部手机，需要手机壳、CPU、操作系统三类对象进行组装，其中每类对象都有不同的种类。对每个具体工厂，分别生产一部手机所需要的三个对象</p><p>相比工厂方法模式，抽象工厂模式中的每个具体工厂都生产一套产品</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象的产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneShell</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneCPU</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_cpu</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneOS</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_os</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 具体的产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallShell</span>(<span class="params">PhoneShell</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;普通手机小手机壳&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigShell</span>(<span class="params">PhoneShell</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;普通手机大手机壳&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleShell</span>(<span class="params">PhoneShell</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;苹果手机壳&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapDragonCPU</span>(<span class="params">PhoneCPU</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_cpu</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;骁龙CPU&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiCPU</span>(<span class="params">PhoneCPU</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_cpu</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;华为CPU&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleCPU</span>(<span class="params">PhoneCPU</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_cpu</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;苹果CPU&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidOS</span>(<span class="params">PhoneOS</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_os</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;AndroidOS系统&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleOS</span>(<span class="params">PhoneOS</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_os</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;IOS系统&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 抽象工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span>(<span class="params">metaclass=ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_cpu</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_os</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiFactory</span>(<span class="params">PhoneFactory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> SmallShell()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_cpu</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HuaweiCPU()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_os</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> AndroidOS()</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span>(<span class="params">PhoneFactory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> AppleShell()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">male_cpu</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> AppleCPU()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_os</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> AppleOS()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, shell, cpu, os</span>):</span></span><br><span class="line">        self.shell = shell</span><br><span class="line">        self.cpu = cpu</span><br><span class="line">        self.os = os</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_info</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;手机信息: &quot;</span>)</span><br><span class="line">        self.shell.show_shell()</span><br><span class="line">        self.cpu.show_cpu()</span><br><span class="line">        self.os.show_os()</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_phone</span>(<span class="params">factory</span>):</span></span><br><span class="line">    shell = factory.make_shell()</span><br><span class="line">    cpu = factory.make_cpu()</span><br><span class="line">    os = factory.make_os()</span><br><span class="line">    <span class="keyword">return</span> Phone(shell, cpu, os)</span><br><span class="line"></span><br><span class="line">p = make_phone(HuaweiFactory())</span><br><span class="line">p.show_info()</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>将客户端与类的具体实现相分离</li><li>每个工厂创建了一个完整的产品系列，使得易于交换产品系列</li><li>有利于产品的一致性（即产品之间的约束关系）</li></ul><p>缺点：</p><ul><li>难以支持新种类的（抽象）产品</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简单工厂设计模式&quot;&gt;&lt;a href=&quot;#简单工厂设计模式&quot; class=&quot;headerlink&quot; title=&quot;简单工厂设计模式&quot;&gt;&lt;/a&gt;简单工厂设计模式&lt;/h3&gt;&lt;p&gt;内容：不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例&lt;/p&gt;
&lt;p&gt;角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象工厂角色（Creator）&lt;/li&gt;
&lt;li&gt;具体工厂角色（Concrete Creator）&lt;/li&gt;
&lt;li&gt;具体产品角色（Concrete Product）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; abc &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; ABCMeta, abstractmethod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Payment&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;metaclass=ABCMeta&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @abstractmethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pay&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, money&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Alipay&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;Payment&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, use_huabei=&lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.use_huabei = use_huabei&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pay&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, money&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; self.use_huabei:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;花呗支付%d元&amp;quot;&lt;/span&gt; % money)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;支付宝支付%d元&amp;quot;&lt;/span&gt; % money)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WechatPay&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;Payment&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pay&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, money&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;微信支付%d元&amp;quot;&lt;/span&gt; % money)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BankPay&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;Payment&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pay&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, money&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;银行卡支付%d元&amp;quot;&lt;/span&gt; % money)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PaymentFactory&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;create_payment&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, method&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; method == &lt;span class=&quot;string&quot;&gt;&amp;#x27;alipay&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Alipay(use_huabei=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; method == &lt;span class=&quot;string&quot;&gt;&amp;#x27;wechat&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; WechatPay()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; method == &lt;span class=&quot;string&quot;&gt;&amp;#x27;bankpay&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; BankPay()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; TypeError(&lt;span class=&quot;string&quot;&gt;&amp;quot;No such payment named %s&amp;quot;&lt;/span&gt; % method)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf = PaymentFactory()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p = pf.create_payment(&lt;span class=&quot;string&quot;&gt;&amp;#x27;alipay&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p.pay(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/Python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python魔法方法</title>
    <link href="http://example.com/2024/05/01/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2024/05/01/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/</id>
    <published>2024-05-01T13:46:54.000Z</published>
    <updated>2024-05-03T14:29:27.175Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在Python中，所有以双下划线<code>__</code>包起来的方法，统称为<strong>Magic Method（魔术方法）</strong>，它是一种的特殊方法，普通方法需要调用，而魔术方法不需要调用就可以自动执行。</p><p>魔术方法在类或对象的某些事件出发后会自动执行，让类具有神奇的“魔力”。如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写。</p><p>Python中常用的运算符、for循环、以及类操作等都是运行在魔术方法之上的。</p><h3><span id="__doc__">__doc__</span></h3><ul><li>表示类的描述信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;描述类信息，这个是工具类&quot;&quot;&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(Foo.__doc__)<span class="comment"># 输出：类的描述信息</span></span><br></pre></td></tr></table></figure><span id="more"></span><h3><span id="__module__-和-__class__">__module__ 和 __class__</span></h3><ul><li><code>__module__</code>表示当前操作的对象在那个模块</li><li><code>__class__</code>表示当前操作的对象的类是什么</li></ul><p>test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.name = <span class="string">&#x27;william&#x27;</span></span><br></pre></td></tr></table></figure><p>main.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> Person</span><br><span class="line"></span><br><span class="line">obj = Person</span><br><span class="line"><span class="built_in">print</span>(obj.__module__)<span class="comment"># 输出 test 即：输出模块</span></span><br><span class="line"><span class="built_in">print</span>(obj.__class__)<span class="comment"># 输出 test.Person 即：输出类</span></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span></span><br><span class="line">&lt;class <span class="string">&#x27;test.Person&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h3><span id="__init__">__init__</span></h3><ul><li>初始化方法，通过类创建对象时，自动触发执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = <span class="number">18</span></span><br><span class="line">    </span><br><span class="line">obj = Person(<span class="string">&#x27;william&#x27;</span>)<span class="comment"># 自动执行类中的 __init__ 方法</span></span><br></pre></td></tr></table></figure><h3><span id="__del__">__del__</span></h3><ul><li>当对象在内存中被释放时，自动触发执行</li></ul><p>此方法一般无需定义，<code>__del__</code>的调用是由解释器在进行垃圾回收时自动触发执行的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3><span id="__call__">__call__</span></h3><ul><li>对象后面加括号，触发执行</li></ul><p><code>__init__</code>方法的执行是由创建对象触发的，即：<code>对象 = 类名()</code>；而对于 <code>__call__</code>方法的执行是由对象后加括号触发的，即<code>对象()</code>或者<code>类()()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__call__&quot;</span>)</span><br><span class="line">    </span><br><span class="line">obj = Foo()<span class="comment"># 执行 __init__</span></span><br><span class="line">obj()<span class="comment"># 执行 __call__</span></span><br></pre></td></tr></table></figure><h3><span id="__dict__">__dict__</span></h3><ul><li>类或对象中的所有属性</li></ul><p>类的实例属性属于对象；类中的类属性和方法属于类，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Province</span>:</span></span><br><span class="line">    country = <span class="string">&quot;China&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, count</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.count = count</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 获取类的属性，即：类属性、方法</span></span><br><span class="line"><span class="built_in">print</span>(Province.__dict__)</span><br><span class="line"><span class="comment"># 输出: &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;country&#x27;: &#x27;China&#x27;, &#x27;__init__&#x27;: &lt;function Province.__init__ at 0x100bd6160&gt;, &#x27;func&#x27;: &lt;function Province.func at 0x100c24f40&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Province&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Province&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">obj1 = Province(<span class="string">&quot;山东&quot;</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="built_in">print</span>(obj1.__dict__)</span><br><span class="line"><span class="comment"># 获取 对象obj1 的属性</span></span><br><span class="line"><span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;山东&#x27;, &#x27;count&#x27;: 10000&#125;</span></span><br><span class="line"></span><br><span class="line">obj2 = Province(<span class="string">&quot;山西&quot;</span>, <span class="number">20000</span>)</span><br><span class="line"><span class="built_in">print</span>(obj2.__dict__)</span><br><span class="line"><span class="comment"># 获取 对象obj2 的属性</span></span><br><span class="line"><span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;山西&#x27;, &#x27;count&#x27;: 20000&#125;</span></span><br></pre></td></tr></table></figure><h3><span id="__str__">__str__</span></h3><ul><li>如果一个类定义了<code>__str__</code>方法，那么打印对象时，默认输出该方法返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;william&#x27;</span></span><br><span class="line">  </span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前对象返回值为: %s&quot;</span> %obj)<span class="comment"># 输出: william</span></span><br></pre></td></tr></table></figure><h3><span id="__repr__">__repr__</span></h3><p>函数<code>__str__</code> 用于将值转化为适于人阅读的形式，而<code>__repr__</code>转化为供解释器读取的形式，某对象没有适于人阅读的解释形式的话，<code>__str__</code>会返回与<code>__repr__</code>，所以<code>print</code>展示的都是<code>__str__</code>的格式。</p><p>默认情况下，<code>__repr__</code> 会返回和调用者有关的 <code>类名+object at+内存地址</code> (&lt;__main__.CLanguage object at 0x000001A7275221D0&gt;)信息。当然，我们还可以通过在类中重写这个方法，从而实现当输出实例化对象时，输出我们想要的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLanguage</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;C语言中文网&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;http://c.biancheng.net&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CLanguage[name=&quot;</span>+ self.name +<span class="string">&quot;,add=&quot;</span> + self.add +<span class="string">&quot;]&quot;</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLanguage[name=C语言中文网,add=http://c.biancheng.net]</span><br></pre></td></tr></table></figure><h3><span id="__getitem__-__setitem__-__delitem__">__getitem__、__setitem__、__delitem__</span></h3><ul><li>用于索引操作，如字典。已上分别表示获取、设置、删除数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__getitem__&quot;</span>, key)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__setitem__&quot;</span>, key, value)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__delitem__&quot;</span>, key)</span><br><span class="line">    </span><br><span class="line">obj = Foo()</span><br><span class="line"></span><br><span class="line">result = obj[<span class="string">&#x27;k1&#x27;</span>]<span class="comment"># 自动触发执行 __getitem__</span></span><br><span class="line">obj[<span class="string">&#x27;k2&#x27;</span>] = <span class="string">&#x27;william&#x27;</span><span class="comment"># 自动触发执行 __setitem__</span></span><br><span class="line"><span class="keyword">del</span> obj[<span class="string">&#x27;k1&#x27;</span>]<span class="comment"># 自动触发执行 __delitem__</span></span><br></pre></td></tr></table></figure><p>我们可以自定义“有序字典”类，它允许我们按照元素插入的顺序进行迭代，并且同时支持通过键来访问、修改和删除元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedDict</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.keys = []  </span><br><span class="line">        self.values = &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span>  </span><br><span class="line">        <span class="comment"># 实现通过键访问值的功能  </span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.values:  </span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">f&quot;Key <span class="subst">&#123;key&#125;</span> not found&quot;</span>)  </span><br><span class="line">        <span class="keyword">return</span> self.values[key]  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span>  </span><br><span class="line">        <span class="comment"># 实现通过键设置值的功能，并维护键的顺序  </span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.keys:  </span><br><span class="line">            self.keys.append(key)  </span><br><span class="line">        self.values[key] = value  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span>  </span><br><span class="line">        <span class="comment"># 实现通过键删除元素的功能，并维护键的顺序  </span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.values:  </span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">f&quot;Key <span class="subst">&#123;key&#125;</span> not found&quot;</span>)  </span><br><span class="line">        self.keys.remove(key)  </span><br><span class="line">        <span class="keyword">del</span> self.values[key]  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        <span class="comment"># 实现迭代功能，按照键的插入顺序迭代值  </span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> self.keys:  </span><br><span class="line">            <span class="keyword">yield</span> self.values[key]  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        <span class="comment"># 提供字符串表示形式，方便查看内容  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;OrderedDict(<span class="subst">&#123;<span class="built_in">repr</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(self.keys, self.values)))&#125;</span>)&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用示例  </span></span><br><span class="line">od = OrderedDict()  </span><br><span class="line">od[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>  </span><br><span class="line">od[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span>  </span><br><span class="line">od[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 访问元素  </span></span><br><span class="line"><span class="built_in">print</span>(od[<span class="string">&#x27;b&#x27;</span>])  <span class="comment"># 输出: 2  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 修改元素  </span></span><br><span class="line">od[<span class="string">&#x27;b&#x27;</span>] = <span class="number">20</span>  </span><br><span class="line"><span class="built_in">print</span>(od[<span class="string">&#x27;b&#x27;</span>])  <span class="comment"># 输出: 20  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除元素  </span></span><br><span class="line"><span class="keyword">del</span> od[<span class="string">&#x27;c&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 迭代元素  </span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> od:  </span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 1 和 20（按插入顺序）  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看内容  </span></span><br><span class="line"><span class="built_in">print</span>(od)  <span class="comment"># 输出: OrderedDict(&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 20&#125;)</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>OrderedDict</code> 类使用两个内部数据结构：一个列表 <code>keys</code> 用于保存键的插入顺序，一个字典 <code>values</code> 用于保存键值对。通过实现 <code>__getitem__</code>、<code>__setitem__</code> 和 <code>__delitem__</code> 方法，我们可以像操作普通字典一样操作 <code>OrderedDict</code> 实例，同时还保留了元素的插入顺序。</p><h3><span id="__getslice__-__setslice__-__delslice__">__getslice__、__setslice__、__delslice__</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getslice__</span>(<span class="params">self, i, j</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;__getslice__&#x27;</span>, i, j)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__setslice__</span>(<span class="params">self, i, j, sequence</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;__setslice__&#x27;</span>, i, j)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__delslice__</span>(<span class="params">self, i, j</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;__delslice__&#x27;</span>, i ,j)</span><br><span class="line">    </span><br><span class="line">obj = Foo()</span><br><span class="line"></span><br><span class="line">obj[-<span class="number">1</span>:<span class="number">1</span>]<span class="comment"># 自动触发执行 __getslice__</span></span><br><span class="line">obj[<span class="number">0</span>:<span class="number">1</span>] = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>]<span class="comment"># 自动触发执行 __setslice__</span></span><br><span class="line"><span class="keyword">del</span> obj[<span class="number">0</span>:<span class="number">2</span>]<span class="comment"># 自动触发执行 __delslice__</span></span><br></pre></td></tr></table></figure><h3><span id="__iter__和__next__">__iter__和__next__</span></h3><p><code>__iter__</code>它允许一个对象定义自己的迭代行为。当你尝试在一个对象上使用迭代（例如，在 <code>for</code> 循环中或在内置函数如 <code>list()</code> 或 <code>sum()</code> 中）时，Python会查找这个对象是否实现了 <code>__iter__</code> 方法。</p><p><code>__iter__</code> 方法应该返回一个迭代器对象，该对象实现了 <code>__iter__</code> 和 <code>__next__</code> 方法。迭代器是一个可以记住遍历的位置的对象。</p><p>以下是一个简单的例子，演示如何在一个自定义类中实现 <code>__iter__</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">max</span></span>):</span></span><br><span class="line">        self.<span class="built_in">max</span> = <span class="built_in">max</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__iter__ called&quot;</span>)</span><br><span class="line">        <span class="comment"># 这里返回self, 因为self对象实现了__next__方法</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__next__ called&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        fib = self.a</span><br><span class="line">        <span class="keyword">if</span> fib &gt; self.<span class="built_in">max</span>:</span><br><span class="line">            <span class="comment"># 当没有更多值可以返回时，__next__方法会抛出一个StopIteration异常，告诉for循环迭代结束</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">return</span> fib</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Fib(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__iter__ called</span><br><span class="line">__next__ called</span><br><span class="line">0</span><br><span class="line">__next__ called</span><br><span class="line">1</span><br><span class="line">__next__ called</span><br><span class="line">1</span><br><span class="line">__next__ called</span><br><span class="line">2</span><br><span class="line">__next__ called</span><br><span class="line">3</span><br><span class="line">__next__ called</span><br><span class="line">5</span><br><span class="line">__next__ called</span><br></pre></td></tr></table></figure><p>定义 <strong>iter</strong> 表示这个类是一个迭代器（iterator）。它只在迭代开始的时候运行一次。返回的是对象本身。这里还给顺手给对象添加了 a 和 b 两个属性。接下来就是循环调用 <strong>next</strong> 直到遇到 raise StopIteration 为止。调用的过程就是模拟斐波那契数列的过程。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Python中，所有以双下划线&lt;code&gt;__&lt;/code&gt;包起来的方法，统称为&lt;strong&gt;Magic Method（魔术方法）&lt;/strong&gt;，它是一种的特殊方法，普通方法需要调用，而魔术方法不需要调用就可以自动执行。&lt;/p&gt;
&lt;p&gt;魔术方法在类或对象的某些事件出发后会自动执行，让类具有神奇的“魔力”。如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写。&lt;/p&gt;
&lt;p&gt;Python中常用的运算符、for循环、以及类操作等都是运行在魔术方法之上的。&lt;/p&gt;
&lt;h3 id=&quot;doc&quot;&gt;&lt;a href=&quot;#doc&quot; class=&quot;headerlink&quot; title=&quot;__doc__&quot;&gt;&lt;/a&gt;__doc__&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;表示类的描述信息&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&amp;quot;描述类信息，这个是工具类&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(Foo.__doc__)		&lt;span class=&quot;comment&quot;&gt;# 输出：类的描述信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python类的方法</title>
    <link href="http://example.com/2024/04/30/Python%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2024/04/30/Python%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2024-04-30T13:40:15.000Z</published>
    <updated>2024-05-03T14:27:02.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li><a href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">类对象与实例对象</a></li><li><a href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E3%80%81%E7%89%B9%E6%80%A7%E6%96%B9%E6%B3%95">实例方法、静态方法、类方法、特性方法</a></li><li><a href="#%E7%89%B9%E6%80%A7%E6%96%B9%E6%B3%95">特性方法</a></li><li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95">抽象类和抽象方法</a></li></ul><h3><span id="类对象与实例对象">类对象与实例对象</span></h3><p>他们在定义和使用中有所区别，而本质的区别是内存中保存的位置不同</p><ul><li>实例属性属于实例对象</li><li>类属性属于类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Province</span>:</span></span><br><span class="line">  <span class="comment"># 类属性</span></span><br><span class="line">  country = <span class="string">&quot;中国&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">    <span class="comment"># 实例属性</span></span><br><span class="line">    self.name = name</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建一个实例对象</span></span><br><span class="line">obj = Province(<span class="string">&quot;山东省&quot;</span>)</span><br><span class="line"><span class="comment"># 直接访问实例属性</span></span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br><span class="line"><span class="comment"># 直接访问类属性</span></span><br><span class="line">Province.country</span><br></pre></td></tr></table></figure><p>由上述代码可以看出【实例属性需要通过对象来访问】【类属性通过类访问】，在使用上可以看出实例属性和类属性的归属是不同的</p><span id="more"></span><p>其在内容的存储方式类似如下图：</p><p><img src="./%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7.png"></p><p>上图中实例对象2，<code>obj1 = Province(&quot;山西省&quot;)</code> 山东省属于笔误</p><p>由此可见：</p><ul><li>类属性在内存中只保存一份</li><li>实例属性在每个对象中都要保存一份</li></ul><h4><span id="应用场景">应用场景</span></h4><ul><li>通过类创建实例对象，如果每个对象需要具有相同名字的属性，那么就使用类属性，用一份即可</li></ul><h3><span id="实例方法-静态方法-类方法-特性方法">实例方法、静态方法、类方法、特性方法</span></h3><p>在 Python 的类里面，在类里面编写的特性函数称为方法，这些方法主要分为普通方法（实例方法），特性方法，静态方法，类方法</p><p>他们都归属于类，区别在于调用方式的不同</p><ul><li>实例方法：由对象调用；至少一个<code>self</code>参数，执行实例方式时，自动将调用该方法的对象赋值给<code>self</code></li><li>类方法：<code>@classmethod</code>由类调用；至少一个<code>cls</code>参数，执行类方法时，自动将调用该方法的类赋值给<code>cls</code></li><li>静态方法：<code>staticmethod</code>由类调用；无默认参数</li><li>特性方法：<code>@property</code>由类调用；不能传入参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ord_func</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义实例方法，至少有一个self参数&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># print(self.name)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;实例方法&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">class_func</span>(<span class="params">cls</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义类方法，至少有一个cls参数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;类方法&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">static_func</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义静态方法，无默认参数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;静态方法&quot;</span>)</span><br><span class="line">    </span><br><span class="line">f = Foo(<span class="string">&quot;中国&quot;</span>)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">f.ord_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用类方法</span></span><br><span class="line">Foo.class_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用静态方法</span></span><br><span class="line">Foo.static_func()</span><br></pre></td></tr></table></figure><h4><span id="对比">对比</span></h4><ul><li>相同点：对于所有的方法而言，均属于类，所以在内存中也只保留一份</li><li>不同点：方法调用者不同，调用方法时自动传入的参数不同</li></ul><h4><span id="为什么会有类方法和静态方法">为什么会有类方法和静态方法</span></h4><p>类方法作用</p><ul><li><strong>修改类状态</strong>：类方法可以直接修改类的状态（类变量），而不需要通过类实例</li><li><strong>无需实例即可访问</strong>：有时，你可能需要执行与类相关的操作，但不需要创建类的实例。在这种情况下，类方法非常有用</li><li><strong>工厂方法</strong>：类方法常常用作工厂方法，用于创建和返回类的实例。由于它们与类本身紧密相关，因此它们可以在创建实例时执行一些与类相关的初始化或设置</li></ul><p>静态方法作用</p><ul><li><strong>组织代码</strong>：有时，你可能有一组与类紧密相关的函数，但这些函数并不需要访问类的状态或实例。将这些函数作为静态方法放在类中可以使代码更具组织性和可读性。</li><li><strong>保持命名空间整洁</strong>：将相关函数放在类中而不是模块级别可以使命名空间更整洁，并减少模块级别的名称冲突。</li><li><strong>访问类属性和其他方法</strong>：尽管静态方法不直接访问类的状态或实例，但它们仍然可以访问类的属性和其他方法（作为类本身的方法）</li></ul><p>以下是类方法的使用场景</p><h4><span id="修改类状态以及无需实例即可访问">修改类状态以及无需实例即可访问</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span>(<span class="params">cls, increment_by = <span class="number">1</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Counter count: <span class="subst">&#123;cls.count&#125;</span>&quot;</span>)</span><br><span class="line">        cls.count += increment_by</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Counter increased by <span class="subst">&#123;increment_by&#125;</span>. New count: <span class="subst">&#123;cls.count&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 使用类方法增加计数器的值，无需创建实例</span></span><br><span class="line">Counter.increment()</span><br><span class="line">Counter.increment(<span class="number">5</span>)</span><br><span class="line">Counter.increment()</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Counter count: 0</span><br><span class="line">Counter increased by 1. New count: 1</span><br><span class="line">Counter count: 1</span><br><span class="line">Counter increased by 5. New count: 6</span><br><span class="line">Counter count: 6</span><br><span class="line">Counter increased by 1. New count: 7</span><br></pre></td></tr></table></figure><h4><span id="工厂方法">工厂方法</span></h4><p>假设我们有一个<code>Shape</code>类，它是一个基类，用于创建不同类型的形状对象。我们可以使用类方法作为工厂方法，根据提供的参数返回不同类型的形状对象</p><p>关乎设计模式的内容，可以搜索下之前的文章</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>:</span>  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">cls, shape_type, **kwargs</span>):</span>  </span><br><span class="line">        <span class="keyword">if</span> shape_type == <span class="string">&#x27;circle&#x27;</span>:  </span><br><span class="line">            <span class="keyword">return</span> Circle(**kwargs)  </span><br><span class="line">        <span class="keyword">elif</span> shape_type == <span class="string">&#x27;rectangle&#x27;</span>:  </span><br><span class="line">            <span class="keyword">return</span> Rectangle(**kwargs)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Unsupported shape type: <span class="subst">&#123;shape_type&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>(<span class="params">Shape</span>):</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radius</span>):</span>  </span><br><span class="line">        self.radius = radius  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>(<span class="params">Shape</span>):</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, width, height</span>):</span>  </span><br><span class="line">        self.width = width  </span><br><span class="line">        self.height = height  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用工厂方法创建形状对象，无需直接实例化特定类  </span></span><br><span class="line">circle = Shape.create(<span class="string">&#x27;circle&#x27;</span>, radius=<span class="number">5</span>)  </span><br><span class="line">rectangle = Shape.create(<span class="string">&#x27;rectangle&#x27;</span>, width=<span class="number">3</span>, height=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>下面是关于静态方法的使用</p><h4><span id="组织代码">组织代码</span></h4><p>假设我们有一个<code>MathUtils</code>类，它包含了一些与数学相关的静态方法。这些静态方法不需要访问类的状态或实例，但它们都与数学计算相关，因此将它们放在同一个类中可以使代码更具组织性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathUtils</span>:</span>  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span>  </span><br><span class="line">        <span class="keyword">return</span> a + b  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">a, b</span>):</span>  </span><br><span class="line">        <span class="keyword">return</span> a * b  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用静态方法进行数学计算  </span></span><br><span class="line">result_add = MathUtils.add(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 结果为 7  </span></span><br><span class="line">result_multiply = MathUtils.multiply(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 结果为 12</span></span><br></pre></td></tr></table></figure><h4><span id="保持命名空间整洁">保持命名空间整洁</span></h4><p>如果我们有一些与特定主题相关的函数，将它们放在一个类中作为静态方法可以使模块级别的命名空间更整洁。例如，我们有一个与文件操作相关的工具集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileUtils</span>:</span>  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_file</span>(<span class="params">file_path</span>):</span>  </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:  </span><br><span class="line">            <span class="keyword">return</span> file.read()  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_file</span>(<span class="params">file_path, content</span>):</span>  </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:  </span><br><span class="line">            file.write(content)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用静态方法进行文件操作  </span></span><br><span class="line">content = FileUtils.read_file(<span class="string">&#x27;example.txt&#x27;</span>)  </span><br><span class="line">FileUtils.write_file(<span class="string">&#x27;new_file.txt&#x27;</span>, <span class="string">&#x27;Hello, world!&#x27;</span>)</span><br></pre></td></tr></table></figure><h4><span id="访问类属性和其他方法">访问类属性和其他方法</span></h4><p>虽然静态方法不依赖于类的实例，但它们仍然可以访问类属性和其他类方法。这在某些情况下可能是有用的，尤其是当你需要在静态方法中调用类的其他功能时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span>  </span><br><span class="line">    class_variable = <span class="string">&quot;I&#x27;m a class variable&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span>(<span class="params">cls</span>):</span>  </span><br><span class="line">        <span class="keyword">return</span> cls.class_variable  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_method</span>():</span>  </span><br><span class="line">        <span class="keyword">return</span> MyClass.class_variable, MyClass.class_method()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用静态方法访问类属性和类方法  </span></span><br><span class="line"><span class="built_in">print</span>(MyClass.static_method())  <span class="comment"># 输出：(&#x27;I&#x27;m a class variable&#x27;, &#x27;I&#x27;m a class variable&#x27;)</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>static_method</code>是一个静态方法，但它通过<code>MyClass</code>类名直接访问了类属性<code>class_variable</code>和类方法<code>class_method</code>。这展示了静态方法如何在不依赖于类的实例的情况下访问类的其他部分</p><h3><span id="特性方法">特性方法</span></h3><p><code>@property</code></p><p>特性方法只具备只读属性，且调用特性方法不能有形参。</p><p>普通方法具备读和写的属性，且调用特性方法可以使用形参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setinfo</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(name, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;name不是字符串的数据类型&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(age, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;age不是整型的数据类型&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self, city</span>):</span></span><br><span class="line">        self.setinfo(self.name, self.age)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;my name is <span class="subst">&#123;self.name&#125;</span>, and my age is <span class="subst">&#123;self.age&#125;</span>, from <span class="subst">&#123;city&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">property_info</span>(<span class="params">self</span>):</span><span class="comment"># 不能传入参数</span></span><br><span class="line">        self.setinfo(self.name, self.age)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;my name is <span class="subst">&#123;self.name&#125;</span>, and my age is <span class="subst">&#123;self.age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    person = Person(<span class="string">&#x27;william&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">    person.info(city=<span class="string">&#x27;xian&#x27;</span>)</span><br><span class="line">    person.property_info<span class="comment"># 调用方法后面没有()</span></span><br></pre></td></tr></table></figure><p>我们看一下实际上有那些使用了<code>@property</code></p><p>在<code>selenium</code>中<code>find_element(By.LINK_TEXT).text</code>方法，使用的是特性方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;The text of the element.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> self._execute(Command.GET_ELEMENT_TEXT)[<span class="string">&quot;value&quot;</span>]</span><br></pre></td></tr></table></figure><h3><span id="抽象类和抽象方法">抽象类和抽象方法</span></h3><p><strong>场景介绍</strong></p><p>假如我们现在实现了一个数据中台的开发，我们对外提供一个接口让不同组件通过这个接口进行访问数据库，来读取数据，我们给数据接口主要有2个功能，</p><ul><li>登录数据库</li><li>读取数据</li><li>执行SQL语句</li></ul><p>可以想象，<strong>登录数据库</strong>这个功能在不同组件之间可以共用，不同组件只需要提供host、user、passwd即可，至于读取数据这是每个组件都必须单独实现的，可以声明为抽象方法，执行SQL语句也是每个子类需要实现的，可以声明为抽象的静态方法。</p><p>Python标准库中有一个模块<strong>abc</strong>可以实现抽象基类和抽象方法，它们的实现方式如下：</p><p><strong>抽象基类</strong>：通过继承abc模块中的ABC类来实现抽象基类。</p><p><strong>抽象方法</strong>：通过装饰器的方法来调用abc模块中abstractmethod方法来注解抽象基类的方法。</p><blockquote><p>abstractmethod注解除了可以实现抽象方法外，还可以注解类方法(@classmethod)、静态方法(@staticmethod)、属性(@property)。</p></blockquote><p>下面就先实现抽象基类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Database</span>(<span class="params">ABC</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self, host, user, password</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Host : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(host))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;User : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(user))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Password : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(password))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Register Success!&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    传入查询数据的SQL语句并执行</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">sql_string</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    执行SQL语句</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>从抽象基类<strong>Database</strong>的实现可以看出，它共包含3个方法，其中<strong>register</strong>是每个子类都需要的，直接实现在抽象基类里，是一个普通的类方法。<strong>query</strong>和<strong>execute</strong>只是在基类中进行类声明，给出了描述，但并没有实现，它限定了继承<strong>Database</strong>的子类必须实现这两个方法。</p><p>下面就来实现两个组件(子类)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component1</span>(<span class="params">Database</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host, user, password</span>):</span></span><br><span class="line">    self.register(host, user, password)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">sql_string</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(sql_string)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">    sql_string = <span class="string">&quot;SELECT ID FROM db_name&quot;</span></span><br><span class="line">    self.execute(sql_string)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component2</span>(<span class="params">Database</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host, user, password</span>):</span></span><br><span class="line">    self.register(host, user, password)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">sql_string</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(sql_string)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">    sql_string = <span class="string">&quot;SELECT ID FROM db_name&quot;</span></span><br><span class="line">    self.execute(sql_string)</span><br><span class="line">    </span><br><span class="line">comp1 = Component1(<span class="string">&quot;00.00.00.00&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;000000&quot;</span>)</span><br><span class="line">comp2 = Component2(<span class="string">&quot;11.11.11.11&quot;</span>, <span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;111111&quot;</span>)</span><br><span class="line">comp1.query()</span><br><span class="line">comp2.query()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Host : <span class="number">00.00</span><span class="number">.00</span><span class="number">.00</span></span><br><span class="line">User : abc</span><br><span class="line">Password : <span class="number">000000</span></span><br><span class="line">Register Success!</span><br><span class="line">Host : <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span></span><br><span class="line">User : ABC</span><br><span class="line">Password : <span class="number">111111</span></span><br><span class="line">Register Success!</span><br><span class="line">SELECT ID FROM db_name</span><br><span class="line">SELECT NAME FROM db_name</span><br></pre></td></tr></table></figure><p>上述是通过Python标准库中abc模块实现了抽象基类，其实在Python中collections中也实现了抽象基类，numbers中也定义了有关数字对象的抽象基类，可见，抽象基类在Python中占据着至关重要的地位。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1&quot;&gt;类对象与实例对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E3%80%81%E7%89%B9%E6%80%A7%E6%96%B9%E6%B3%95&quot;&gt;实例方法、静态方法、类方法、特性方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%89%B9%E6%80%A7%E6%96%B9%E6%B3%95&quot;&gt;特性方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95&quot;&gt;抽象类和抽象方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类对象与实例对象&quot;&gt;&lt;a href=&quot;#类对象与实例对象&quot; class=&quot;headerlink&quot; title=&quot;类对象与实例对象&quot;&gt;&lt;/a&gt;类对象与实例对象&lt;/h3&gt;&lt;p&gt;他们在定义和使用中有所区别，而本质的区别是内存中保存的位置不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例属性属于实例对象&lt;/li&gt;
&lt;li&gt;类属性属于类&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Province&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;# 类属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  country = &lt;span class=&quot;string&quot;&gt;&amp;quot;中国&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, name&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 实例属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.name = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建一个实例对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj = Province(&lt;span class=&quot;string&quot;&gt;&amp;quot;山东省&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接访问实例属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(obj.name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 直接访问类属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Province.country&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;由上述代码可以看出【实例属性需要通过对象来访问】【类属性通过类访问】，在使用上可以看出实例属性和类属性的归属是不同的&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python深拷贝与浅拷贝</title>
    <link href="http://example.com/2024/04/30/Python%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://example.com/2024/04/30/Python%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2024-04-30T11:49:41.000Z</published>
    <updated>2024-05-03T14:29:56.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3><span id="python的引用计数">Python的引用计数</span></h3><p>首先我们要知道，Python 内<strong>不可变对象</strong>的内存管理方式是引用计数。因此，我们在谈论浅拷贝时，其实谈论的主要特点都是基于可变对象的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;hello&#x27;</span>  <span class="comment"># python的不可变对象：元组，数值，字符串</span></span><br><span class="line">b = a</span><br><span class="line">c = copy.copy(a)</span><br><span class="line">d = copy.deepcopy(c)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(c))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(d))</span><br></pre></td></tr></table></figure><span id="more"></span><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4310112880</span><br><span class="line">4310112880</span><br><span class="line">4310112880</span><br><span class="line">4310112880</span><br></pre></td></tr></table></figure><p>因为我们这里操作的是不可变对象，Python 用引用计数的方式管理它们，所以 Python 不会对值相同的不可变对象，申请单独的内存空间。只会记录它的引用次数</p><p>操作不可变对象时，由于引用计数的特性，浅拷贝和深拷贝是没有区别的</p><h3><span id="浅拷贝shallow-copy">浅拷贝（Shallow Copy）</span></h3><p>我们先来比较一下浅拷贝和赋值在可变对象上的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="string">&#x27;123&#x27;</span>]</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line"></span><br><span class="line">c = copy.copy(a)</span><br><span class="line"></span><br><span class="line">d = copy.deepcopy(c)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(c))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(d))</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4372413312</span><br><span class="line">4372413312</span><br><span class="line">4372889152</span><br><span class="line">4372889216</span><br></pre></td></tr></table></figure><p><code>赋值</code>就是对物体进行贴标签的操作，作用于同一个物体</p><p><code>浅拷贝</code>则会创建一个新的对象，至于对象中的元素，它依然会引用原来的物体，请看下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="string">&#x27;123&#x27;</span>]</span><br><span class="line"></span><br><span class="line">c = copy.copy(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(c))</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;555&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a的值为: <span class="subst">&#123;a&#125;</span>, a的内存地址为: <span class="subst">&#123;<span class="built_in">id</span>(a)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c的值为: <span class="subst">&#123;c&#125;</span>, c的内存地址为: <span class="subst">&#123;<span class="built_in">id</span>(c)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4337646464</span><br><span class="line">4338122688</span><br><span class="line">a的值为: [<span class="string">&#x27;555&#x27;</span>], a的内存地址为: 4337646464</span><br><span class="line">c的值为: [<span class="string">&#x27;123&#x27;</span>], c的内存地址为: 4338122688</span><br></pre></td></tr></table></figure><p><img src="./%E6%B5%85%E6%8B%B7%E8%B4%9D.png"></p><hr><p>由于浅拷贝会使用原始元素的引用（内存地址）。所以在操作被拷贝对象内部可变元素时，其结果是会影响到拷贝对象的</p><p>现在，我们看下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [[<span class="string">&#x27;aaa&#x27;</span>],<span class="string">&#x27;bbb&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">c = copy.copy(a)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p><img src="%E6%B5%85%E6%8B%B7%E8%B4%9D2.png"></p><h3><span id="深拷贝deep-copy">深拷贝（Deep Copy）</span></h3><p>深拷贝遇到可变对象，则又会进行一层对象创建，所以你操作被拷贝对象内部的可变对象，不影响对象内部的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [[<span class="string">&#x27;aaa&#x27;</span>],<span class="string">&#x27;bbb&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a的值为: <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = copy.copy(a)</span><br><span class="line">d = copy.deepcopy(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;浅拷贝c的值为: <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;深拷贝d的值为: <span class="subst">&#123;d&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改后a的值为: <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;浅拷贝c的值为: <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;深拷贝d的值为: <span class="subst">&#123;d&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a的值为: [[<span class="string">&#x27;aaa&#x27;</span>], <span class="string">&#x27;bbb&#x27;</span>]</span><br><span class="line">浅拷贝c的值为: [[<span class="string">&#x27;aaa&#x27;</span>], <span class="string">&#x27;bbb&#x27;</span>]</span><br><span class="line">深拷贝d的值为: [[<span class="string">&#x27;aaa&#x27;</span>], <span class="string">&#x27;bbb&#x27;</span>]</span><br><span class="line">-------------</span><br><span class="line">修改后a的值为: [[<span class="string">&#x27;tom&#x27;</span>], <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line">浅拷贝c的值为: [[<span class="string">&#x27;tom&#x27;</span>], <span class="string">&#x27;bbb&#x27;</span>]</span><br><span class="line">深拷贝d的值为: [[<span class="string">&#x27;aaa&#x27;</span>], <span class="string">&#x27;bbb&#x27;</span>]</span><br></pre></td></tr></table></figure><p><img src="%E6%B7%B1%E6%8B%B7%E8%B4%9D.png"></p><h3><span id="总结">总结</span></h3><ol><li>由于Python内部引用计数器的特性，对于不可变对象，浅拷贝和深拷贝的作用是一样的，指针指向同一个地址</li><li>浅拷贝的拷贝，其实是拷贝了原始元素的引用（内存地址），所以当拷贝可变对象时，原对象内可变对象的对应元素的改变，会在复制对象的对应元素上，有所体现</li><li>深拷贝遇到可变对象时，又在内部新建了一个副本。所以，不管它内部的元素如何变化，都不会影响到原来副本的可变对象</li></ol><h3><span id="实际应用场景">实际应用场景</span></h3><p>那么讲了这么多，他们的实际应用场景又是什么呢？这也是网上讲的最少的部分了</p><ol><li><p><strong>避免修改原始数据</strong>：当你需要修改一个对象，但又不想影响原始数据时，深拷贝是一个很好的选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">original_dict = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: [<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">deep_copy = copy.deepcopy(original_dict)</span><br><span class="line"></span><br><span class="line">deep_copy[<span class="string">&#x27;b&#x27;</span>][<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(original_dict)</span><br><span class="line"><span class="built_in">print</span>(deep_copy)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: 1, <span class="string">&#x27;b&#x27;</span>: [2, 3]&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: 1, <span class="string">&#x27;b&#x27;</span>: [4, 3]&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置文件的处理</strong>：当你从配置文件中读取数据并希望对其进行修改，但同时又希望保留原始配置文件的内容时，深拷贝非常有用</p></li><li><p><strong>多线程/多进程中数据安全</strong>：在多线程或多进程环境中，你可能需要确保一个对象在多线程或多进程之间是独立的。通过深拷贝，你可以为每个线程或进程提过一个独立的对象副本</p></li></ol><p><em>注意：</em>深拷贝可能会消耗更多的内存和时间，因为它需要递归的复制对象的所有内容。因此，在选择使用深拷贝还是浅拷贝时，需要权衡你具体需求（如性能、内存使用等）和场景</p><h3><span id="引用">引用</span></h3><p><a href="https://zhuanlan.zhihu.com/p/57893374">5张图彻底理解Python中的浅拷贝与深拷贝</a></p><p><a href="https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html">Python 直接赋值、浅拷贝和深度拷贝解析</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Python的引用计数&quot;&gt;&lt;a href=&quot;#Python的引用计数&quot; class=&quot;headerlink&quot; title=&quot;Python的引用计数&quot;&gt;&lt;/a&gt;Python的引用计数&lt;/h3&gt;&lt;p&gt;首先我们要知道，Python 内&lt;strong&gt;不可变对象&lt;/strong&gt;的内存管理方式是引用计数。因此，我们在谈论浅拷贝时，其实谈论的主要特点都是基于可变对象的。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; copy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# python的不可变对象：元组，数值，字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c = copy.copy(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d = copy.deepcopy(c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;id&lt;/span&gt;(a))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;id&lt;/span&gt;(b))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;id&lt;/span&gt;(c))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;id&lt;/span&gt;(d))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>logging日志模块</title>
    <link href="http://example.com/2024/04/11/logging%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2024/04/11/logging%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/</id>
    <published>2024-04-10T16:39:51.000Z</published>
    <updated>2024-04-10T16:42:12.319Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3><span id="logging库日志级别">Logging库日志级别</span></h3><table><thead><tr><th>级别</th><th>级别数值</th><th>使用时机</th></tr></thead><tbody><tr><td>DEBUG</td><td>10</td><td>详细信息，常用于调试</td></tr><tr><td>INFO</td><td>20</td><td>程序正常运行过程中产生的一些信息</td></tr><tr><td>WARNNING</td><td>30</td><td>警告用户，虽然程序还在正常工作，但有可能发生错误</td></tr><tr><td>ERROR</td><td>40</td><td>由于更严重的问题，程序已不能执行一些功能了</td></tr><tr><td>CRITICAL</td><td>50</td><td>严重错误，程序已不能继续运行</td></tr></tbody></table><p><strong>默认的日志级别是warning</strong></p><span id="more"></span><p>我们来看一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认的日志输出级别为Warning</span></span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&quot;This is a debug message&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;This is an info&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;This is an warning&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;This is an error&quot;</span>)</span><br><span class="line">logging.critical(<span class="string">&quot;This is an critical&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING:root:This is an warning</span><br><span class="line">ERROR:root:This is an error</span><br><span class="line">CRITICAL:root:This is an critical</span><br></pre></td></tr></table></figure><p>正常不会打印出debug和info日志。现在我们更改下日志输出的级别，将日志的输出级别改成DEBUG</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认的日志输出级别为Warning</span></span><br><span class="line"><span class="comment"># 使用baseConfig()来指定日志输出级别</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">&quot;This is a debug message&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;This is an info&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;This is an warning&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;This is an error&quot;</span>)</span><br><span class="line">logging.critical(<span class="string">&quot;This is an critical&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEBUG:root:This is a debug message</span><br><span class="line">INFO:root:This is an info</span><br><span class="line">WARNING:root:This is an warning</span><br><span class="line">ERROR:root:This is an error</span><br><span class="line">CRITICAL:root:This is an critical</span><br></pre></td></tr></table></figure><p>现在打印出了所有的日志了</p><h3><span id="loggingbasicconfig">Logging.basicConfig()</span></h3><p><strong>logging.basicConfig()</strong> 的参数除了日志等级的这个参数可以设置以外，还可以设置其他的参数，比如：</p><table><thead><tr><th align="left">格式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>filename</em></td><td align="left">使用指定的文件名创建一个 <a href="https://docs.python.org/zh-cn/3/library/logging.handlers.html#logging.FileHandler"><code>FileHandler</code></a>，而不是 <a href="https://docs.python.org/zh-cn/3/library/logging.handlers.html#logging.StreamHandler"><code>StreamHandler</code></a>。</td></tr><tr><td align="left"><em>filemode</em></td><td align="left">如果指定了 <em>filename</em>，则用此 <a href="https://docs.python.org/zh-cn/3/library/functions.html#filemodes">模式</a> 打开该文件。 默认模式为 <code>&#39;a&#39;</code>。</td></tr><tr><td align="left"><em>format</em></td><td align="left">使用指定的格式字符串作为处理器。 默认为属性以冒号分隔的 <code>levelname</code>, <code>name</code> 和 <code>message</code>。</td></tr><tr><td align="left"><em>datefmt</em></td><td align="left">使用指定的日期/时间格式，与 <a href="https://docs.python.org/zh-cn/3/library/time.html#time.strftime"><code>time.strftime()</code></a> 所接受的格式相同。</td></tr><tr><td align="left"><em>style</em></td><td align="left">如果指定了 <em>format</em>，将为格式字符串使用此风格。 <code>&#39;%&#39;</code>, <code>&#39;&#123;&#39;</code> 或 <code>&#39;$&#39;</code> 分别对应于 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting">printf 风格</a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/string.html#string.Template"><code>string.Template</code></a>。 默认为 <code>&#39;%&#39;</code>。</td></tr><tr><td align="left"><em>level</em></td><td align="left">设置根记录器级别为指定的 <a href="https://docs.python.org/zh-cn/3/library/logging.html#levels">level</a>.</td></tr><tr><td align="left"><em>stream</em></td><td align="left">使用指定的流初始化 <a href="https://docs.python.org/zh-cn/3/library/logging.handlers.html#logging.StreamHandler"><code>StreamHandler</code></a>。 请注意此参数与 <em>filename</em> 不兼容 —— 如果两者同时存在，则会引发 <code>ValueError</code>。</td></tr><tr><td align="left"><em>handlers</em></td><td align="left">如果指定，这应为一个包含要加入根日志记录器的已创建处理器的可迭代对象。 任何尚未设置格式描述符的处理器将被设置为在此函数中创建的默认格式描述符。 请注意此参数与 <em>filename</em> 或 <em>stream</em> 不兼容 —— 如果两者同时存在，则会引发 <code>ValueError</code>。</td></tr><tr><td align="left"><em>force</em></td><td align="left">如果将此关键字参数指定为 true，则在执行其他参数指定的配置之前，将移除并关闭附加到根记录器的所有现有处理器。</td></tr><tr><td align="left"><em>encoding</em></td><td align="left">如果此关键字参数与 <em>filename</em> 一同被指定，则其值会在创建 <a href="https://docs.python.org/zh-cn/3/library/logging.handlers.html#logging.FileHandler"><code>FileHandler</code></a> 时被使用，因而也会在打开输出文件时被使用。</td></tr><tr><td align="left"><em>errors</em></td><td align="left">如果此关键字参数与 <em>filename</em> 一同被指定，则其值会在创建 <a href="https://docs.python.org/zh-cn/3/library/logging.handlers.html#logging.FileHandler"><code>FileHandler</code></a> 时被使用，因而也会在打开输出文件时被使用。 如果未指定，则会使用值 ‘backslashreplace’。 请注意如果指定为 <code>None</code>，它将被原样传给 <a href="https://docs.python.org/zh-cn/3/library/functions.html#open"><code>open()</code></a>，这意味着它将会当作传入 ‘errors’ 一样处理。</td></tr></tbody></table><p>上表提到的日志的输出格式参数format，其控制着日志输出的一些格式：</p><table><thead><tr><th align="left">属性名称</th><th align="left">格式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">args</td><td align="left">此属性不需要用户进行格式化。</td><td align="left">合并到 <code>msg</code> 以产生 <code>message</code> 的包含参数的元组，或是其中的值将被用于合并的字典（当只有一个参数且其类型为字典时）。</td></tr><tr><td align="left">asctime</td><td align="left"><code>%(asctime)s</code></td><td align="left">表示人类易读的 <a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> 生成时间。 默认形式为 ‘2003-07-08 16:49:45,896’ （逗号之后的数字为时间的毫秒部分）。</td></tr><tr><td align="left">created</td><td align="left"><code>%(created)f</code></td><td align="left"><a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> 被创建的时间（即 <a href="https://docs.python.org/zh-cn/3/library/time.html#time.time"><code>time.time()</code></a> 的返回值）。</td></tr><tr><td align="left">exc_info</td><td align="left">此属性不需要用户进行格式化。</td><td align="left">异常元组（例如 <code>sys.exc_info</code>）或者如未发生异常则为 <code>None</code>。</td></tr><tr><td align="left">filename</td><td align="left"><code>%(filename)s</code></td><td align="left"><code>pathname</code> 的文件名部分。</td></tr><tr><td align="left">funcName</td><td align="left"><code>%(funcName)s</code></td><td align="left">函数名包括调用日志记录.</td></tr><tr><td align="left">levelname</td><td align="left"><code>%(levelname)s</code></td><td align="left">消息文本记录级别（<code>&#39;DEBUG&#39;</code>，<code>&#39;INFO&#39;</code>，<code>&#39;WARNING&#39;</code>，<code>&#39;ERROR&#39;</code>，<code>&#39;CRITICAL&#39;</code>）。</td></tr><tr><td align="left">levelno</td><td align="left"><code>%(levelno)s</code></td><td align="left">消息数字的记录级别 (<a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.DEBUG"><code>DEBUG</code></a>, <a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.INFO"><code>INFO</code></a>, <a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.WARNING"><code>WARNING</code></a>, <a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.ERROR"><code>ERROR</code></a>, <a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.CRITICAL"><code>CRITICAL</code></a>).</td></tr><tr><td align="left">lineno</td><td align="left"><code>%(lineno)d</code></td><td align="left">发出日志记录调用所在的源行号（如果可用）。</td></tr><tr><td align="left">message</td><td align="left"><code>%(message)s</code></td><td align="left">记入日志的消息，即 <code>msg % args</code> 的结果。 这是在发起调用 <a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.Formatter.format"><code>Formatter.format()</code></a> 时设置的。</td></tr><tr><td align="left">module</td><td align="left"><code>%(module)s</code></td><td align="left">模块 (<code>filename</code> 的名称部分)。</td></tr><tr><td align="left">msecs</td><td align="left"><code>%(msecs)d</code></td><td align="left"><a href="https://docs.python.org/zh-cn/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> 被创建的时间的毫秒部分。</td></tr><tr><td align="left">msg</td><td align="left">此属性不需要用户进行格式化。</td><td align="left">在原始日志记录调用中传入的格式字符串。 与 <code>args</code> 合并以产生 <code>message</code>，或是一个任意对象 (参见 <a href="https://docs.python.org/zh-cn/3/howto/logging.html#arbitrary-object-messages">使用任意对象作为消息</a>)。</td></tr><tr><td align="left">name</td><td align="left"><code>%(name)s</code></td><td align="left">用于记录调用的日志记录器名称。</td></tr><tr><td align="left">pathname</td><td align="left"><code>%(pathname)s</code></td><td align="left">发出日志记录调用的源文件的完整路径名（如果可用）。</td></tr><tr><td align="left">process</td><td align="left"><code>%(process)d</code></td><td align="left">进程ID（如果可用）</td></tr><tr><td align="left">processName</td><td align="left"><code>%(processName)s</code></td><td align="left">进程名（如果可用）</td></tr><tr><td align="left">relativeCreated</td><td align="left"><code>%(relativeCreated)d</code></td><td align="left">以毫秒数表示的 LogRecord 被创建的时间，即相对于 logging 模块被加载时间的差值。</td></tr><tr><td align="left">stack_info</td><td align="left">此属性不需要用户进行格式化。</td><td align="left">当前线程中从堆栈底部起向上直到包括日志记录调用并引发创建当前记录堆栈帧创建的堆栈帧信息（如果可用）。</td></tr><tr><td align="left">thread</td><td align="left"><code>%(thread)d</code></td><td align="left">线程ID（如果可用）</td></tr><tr><td align="left">threadName</td><td align="left"><code>%(threadName)s</code></td><td align="left">线程名（如果可用）</td></tr></tbody></table><p>我们来看看怎么使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认的日志输出级别为Warning</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(filename=<span class="string">&#x27;message.log&#x27;</span>,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(filename)s:%(lineno)s - %(levelname)s - %(message)s&#x27;</span>,</span><br><span class="line">                    level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">&quot;This is a debug message&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;This is an info&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;This is an warning&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;This is an error&quot;</span>)</span><br><span class="line">logging.critical(<span class="string">&quot;This is an critical&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>filemode也是一个常用的参数，不设的话默认为<code>&#39;a&#39;</code>，即追加模式；也可以设为<code>&#39;w&#39;</code>，那么每次写日志会覆盖之前的日志。</strong></p><p>上述产生的日志文件<code>message.log</code>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2024-04-10 22:35:26,490 - root - test.py:8 - DEBUG - This is a debug message</span><br><span class="line">2024-04-10 22:35:26,490 - root - test.py:9 - INFO - This is an info</span><br><span class="line">2024-04-10 22:35:26,491 - root - test.py:10 - WARNING - This is an warning</span><br><span class="line">2024-04-10 22:35:26,491 - root - test.py:11 - ERROR - This is an error</span><br><span class="line">2024-04-10 22:35:26,491 - root - test.py:12 - CRITICAL - This is an critical</span><br></pre></td></tr></table></figure><h3><span id="logging组件">Logging组件</span></h3><p>Logging中除了以上的一些设置之外，logging还提供了几个组件（类）供我们实现一些特殊的功能，它们主要是：</p><table><thead><tr><th>组件名称</th><th>对应类名</th><th>对应描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可以一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将创建的日志记录发送到合适的目的地输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细颗粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>这些组件共同完成日志的配置和输出：</p><ul><li><code>Logger</code>需要通过<code>handler</code>将日志信息输出到目标位置，目标位置可以是<code>sys.stdout</code>和文件等。</li><li>不同的Handler可以将日志输出到不同的位置(不同的日志文件)。</li><li><code>Logger</code>可以设置多个<code>handler</code>将同一条日志记录输出到不同的位置。</li><li>每个<code>Handler</code>都可以设置自己的<code>filter</code>从而实现日志过滤，保留实际项目中需要的日志。</li><li><code>formatter</code>实现同一条日志以不同的格式输出到不同的地方。</li></ul><p><strong>简单的说就是：日志器作为入口，通过设置处理器的方式将日志输出，处理器再通过过滤器和格式器对日志进行相应的处理操作。</strong></p><p>我们来简单的介绍一下这些组件中一些常用的方法：</p><h4><span id="logger-日志器">Logger 日志器</span></h4><ol><li><p>提供应用程序的调用接口</p><p><code>logger = logging.getLogger(__name__)</code></p><p><code>logger</code>是单例的</p></li><li><p>决定日志记录的级别</p><p><code>logger.setLevel()</code></p></li><li><p>将日志内容传递到相关联的<code>headlers</code>中</p><p><code>logger.addHandler() 和 logger.removeHandler()</code></p></li></ol><table><thead><tr><th>方法</th><th>方法描述</th></tr></thead><tbody><tr><td>Logger.setLevel()</td><td>设置日志器将会处理的日志消息级别</td></tr><tr><td>Logger.addHander()</td><td>添加一个<code>handler</code>对象</td></tr><tr><td>Logger.addFilter()</td><td>添加一个<code>filter</code>对象</td></tr><tr><td>Logger.removeHander()</td><td>移除一个<code>handler</code>对象</td></tr><tr><td>Logger.removeFilter()</td><td>移除一个<code>filter</code>对象</td></tr><tr><td>Logger.debug()</td><td>设置DEBUG级别的日志记录</td></tr><tr><td>Logger.info()</td><td>设置INFO级别的日志记录</td></tr><tr><td>Logger.exception()</td><td>输出堆栈追踪信息</td></tr><tr><td>Logger.log()</td><td>设置一个自定义的<code>lever</code>参数来创建一个日志记录</td></tr></tbody></table><h4><span id="handler-处理器">Handler 处理器</span></h4><p><code>Handler</code>将日志分发到不同的目的地。可以是文件、标准输出、邮件、或者通过<code>socke</code>、<code>http</code>等协议发送到任何地方</p><p><font color="orange"><code>StreamHeadler</code></font></p><p>标准输出<code>stdout</code>（如显示器）分发器</p><p>创建方法：<code>sh = logging.StreamHandler(stream=None)</code></p><p><font color="orange"><code>FileHandler</code></font></p><p>将日志保存到磁盘文件的处理器</p><p>创建方法：<code>fh = logging.FileHandler(filename, mode=&#39;a&#39;, encoding=None, delay=False)</code></p><p><code>setFormatter():</code> 设置当前handler对象使用的消息格式</p><table><thead><tr><th>方法</th><th>方法描述</th></tr></thead><tbody><tr><td>logging.StreamHandler()</td><td>它可将日志记录输出发送到数据流例如 <em>sys.stdout</em>, <em>sys.stderr</em> 或任何文件型对象（或者更精确地说，任何支持 <code>write()</code> 和 <code>flush()</code> 方法的对象）。</td></tr><tr><td>logging.FileHandler()</td><td>它可将日志记录输出到磁盘文件中</td></tr><tr><td>RotatingFileHandler()</td><td>将日志消息发送到磁盘文件，支持日志文件按大小切割</td></tr><tr><td>BaseRotatingHandler()</td><td>它是轮换文件处理程序类</td></tr><tr><td>TimedRotatingFileHandler()</td><td>将日志消息发送到磁盘文件，并支持日志文件按时间切割</td></tr></tbody></table><h4><span id="fliter-过滤器">Fliter 过滤器</span></h4><p>看名字大家就知道这是一个过滤类，那么过滤什么呢？</p><p>Filter可以被Handler和Logger用来做比之前设置的日志等级level更为细粒度的、更复杂的相关过滤功能。</p><p>简单的说Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤，保存下来。该类定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span>.<span class="title">Filter</span>(<span class="title">name</span></span>=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    filter(record)</span><br></pre></td></tr></table></figure><p>过滤举例：</p><p>例如用 ‘A.B’ 初始化的 Filter，那么其允许Logger ‘A.B’, ‘A.B.C’, ‘A.B.C.D’, ‘A.B.D’ 等日志记录的事件，logger‘A.BB’, ‘B.A.B’ 等就不满足过滤的条件。</p><p>如果用空字符串来对Filter初始化，所有日志记录的事件都将不会被过滤。</p><h4><span id="formatter-格式器">Formatter 格式器</span></h4><p><code>Formater</code>主要负责日志的格式化输出的</p><p>构造方法：<code>ft = logging.Formatter.__init__(fmt=None, datefmt=None, style=&#39; %&#39;)</code></p><p><code>datefmt</code>默认是<code>%Y-%m-%d %H:%M:%S</code>样式的</p><p><code>style</code>参数默认为百分符%，这表示<code>%(&lt;dictionary key&gt;)s</code>格式的字符串</p><p>如果使用<code>logging</code>的组件呢，来看下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># logger 日志器</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;applog&#x27;</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)<span class="comment"># console 和 file 想要打印不同的日志级别，需要logger设置成DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理器handler</span></span><br><span class="line">consoleHandler = logging.StreamHandler()</span><br><span class="line">consoleHandler.setLevel(logging.DEBUG)  <span class="comment"># console 打印的日志级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有给handler指定日志级别，将使用logger的级别</span></span><br><span class="line">fileHandler = logging.FileHandler(filename=<span class="string">&#x27;message.log&#x27;</span>)</span><br><span class="line">fileHandler.setLevel(logging.INFO)<span class="comment"># file 打印日志级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># formatter 格式</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s [%(levelname)s] [%(filename)s:%(lineno)s] [%(name)s] %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给处理器设置格式</span></span><br><span class="line">consoleHandler.setFormatter(formatter)</span><br><span class="line">fileHandler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录器设置处理器</span></span><br><span class="line">logger.addHandler(consoleHandler)</span><br><span class="line">logger.addHandler(fileHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志打印</span></span><br><span class="line">logger.debug(<span class="string">&#x27;This is a debug message&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;This is an info message&#x27;</span>)</span><br><span class="line">logger.warning(<span class="string">&#x27;This is an warning message&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;This is an error message&#x27;</span>)</span><br><span class="line">logger.critical(<span class="string">&#x27;This is an critical message&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2024-04-10 23:46:28,312 [DEBUG] [test1.py:26] [applog] This is a debug message</span><br><span class="line">2024-04-10 23:46:28,313 [INFO] [test1.py:27] [applog] This is an info message</span><br><span class="line">2024-04-10 23:46:28,313 [WARNING] [test1.py:28] [applog] This is an warning message</span><br><span class="line">2024-04-10 23:46:28,313 [ERROR] [test1.py:29] [applog] This is an error message</span><br><span class="line">2024-04-10 23:46:28,313 [CRITICAL] [test1.py:30] [applog] This is an critical message</span><br></pre></td></tr></table></figure><h3><span id="配置文件">配置文件</span></h3><h4><span id="conf形式配置文件"><code>conf</code>形式配置文件</span></h4><p>我们知道在**logging.basicConfig()**中，是进行一些日志的配置的，如果每次都去改动代码，那将变得十分的麻烦，特别是在程序发布或者上线的时候。所以我们可以使用一个什么好的方法来规避这个问题呢？有的，那就是配置文件。</p><p>我们在文件<strong>logging.conf</strong>中写入相关的信息，内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[loggers]</span></span><br><span class="line"><span class="attr">keys</span>=root,appname</span><br><span class="line"></span><br><span class="line"><span class="section">[handlers]</span></span><br><span class="line"><span class="attr">keys</span>=fileHandler,consoleHandler</span><br><span class="line"></span><br><span class="line"><span class="section">[formatters]</span></span><br><span class="line"><span class="attr">keys</span>=simpleFormatter</span><br><span class="line"></span><br><span class="line"><span class="section">[logger_root]</span></span><br><span class="line"><span class="attr">level</span>=DEBUG</span><br><span class="line"><span class="comment">; logger.addHandler(consoleHandler)</span></span><br><span class="line"><span class="attr">handlers</span>=consoleHandler</span><br><span class="line"></span><br><span class="line"><span class="section">[logger_appname]</span></span><br><span class="line"><span class="attr">level</span>=DEBUG</span><br><span class="line"><span class="attr">handlers</span>=fileHandler,consoleHandler</span><br><span class="line"><span class="comment">; 别名 logging.getLogger(&#x27;appname&#x27;)</span></span><br><span class="line"><span class="attr">qualname</span>=appname</span><br><span class="line"><span class="comment">; 继承关系 0 不继承</span></span><br><span class="line"><span class="attr">propagate</span>=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[handler_consoleHandler]</span></span><br><span class="line"><span class="comment">; consoleHandler = logging.StreamHandler()</span></span><br><span class="line"><span class="attr">class</span>=StreamHandler</span><br><span class="line"><span class="comment">; sys.stdout 标准输出，即 console 输出</span></span><br><span class="line"><span class="attr">args</span>=(sys.stdout,)</span><br><span class="line"><span class="attr">level</span>=DEBUG</span><br><span class="line"><span class="attr">formatter</span>=simpleFormatter</span><br><span class="line"></span><br><span class="line"><span class="section">[handler_fileHandler]</span></span><br><span class="line"><span class="attr">class</span>=handlers.TimedRotatingFileHandler</span><br><span class="line"><span class="comment">; 日志滚动更新，每天24点分隔日志，1 代表 delay多少s，0 代表文件保留的时间，0即不删除</span></span><br><span class="line"><span class="attr">args</span>=(<span class="string">&#x27;appname.log&#x27;</span>, <span class="string">&#x27;midnight&#x27;</span>, <span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line"><span class="attr">level</span>=DEBUG</span><br><span class="line"><span class="attr">formatter</span>=simpleFormatter</span><br><span class="line"></span><br><span class="line"><span class="section">[formatter_simpleFormatter]</span></span><br><span class="line"><span class="attr">format</span>=%(asctime)s [%(levelname)s] [%(filename)s:%(line<span class="literal">no</span>)s] [%(name)s] %(message)s</span><br><span class="line"><span class="comment">;datefmt=%Y-%m-%d %H:%M:%S</span></span><br></pre></td></tr></table></figure><p>使用配置文件的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入配置文件信息</span></span><br><span class="line">logging.config.fileConfig(<span class="string">&#x27;logging.conf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rootLogger = logging.getLogger()</span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;appname&#x27;</span>)</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br><span class="line">rootLogger.info(<span class="string">&#x27;info message&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>(a)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    logger.exception(e)<span class="comment"># 使用logger.exception() 捕获异常，而非 logger.error()</span></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2024-04-11 00:28:56,077 [DEBUG] [test2.py:9] [appname] debug message</span><br><span class="line">2024-04-11 00:28:56,077 [INFO] [test2.py:10] [root] info message</span><br><span class="line">2024-04-11 00:28:56,077 [ERROR] [test2.py:17] [appname] invalid literal <span class="keyword">for</span> int() with base 10: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/william/Desktop/tmp/logger_manager/test2.py&quot;</span>, line 15, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    int(a)</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> int() with base 10: <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure><h3><span id="自定义logger日志输出文件">自定义<code>logger</code>日志输出文件</span></h3><p>以上介绍的知识点，大家在平时或在实际的项目中使用基本上就足够了，下面我们简单的介绍一下怎么进行自定义logger进行日志的输出。</p><p>我们写一个<strong>sel_def_logger.py</strong>文件，文件中的定义一个类，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime</span><br><span class="line"><span class="comment"># 输出日志路径</span></span><br><span class="line">PATH = os.path.abspath(<span class="string">&#x27;.&#x27;</span>) + <span class="string">&#x27;/logs/&#x27;</span></span><br><span class="line"><span class="comment"># 设置日志格式#和时间格式</span></span><br><span class="line">FMT = <span class="string">&#x27;%(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s: %(message)s&#x27;</span></span><br><span class="line">DATEFMT = <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.logger = logging.getLogger()</span><br><span class="line">        self.formatter = logging.Formatter(fmt=FMT, datefmt=DATEFMT)</span><br><span class="line">        self.log_filename = <span class="string">&#x27;&#123;0&#125;&#123;1&#125;.log&#x27;</span>.<span class="built_in">format</span>(PATH, strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>))</span><br><span class="line"></span><br><span class="line">        self.logger.addHandler(self.get_file_handler(self.log_filename))</span><br><span class="line">        self.logger.addHandler(self.get_console_handler())</span><br><span class="line">        <span class="comment"># 设置日志的默认级别</span></span><br><span class="line">        self.logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出到文件handler的函数定义</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_file_handler</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">        filehandler = logging.FileHandler(filename, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        filehandler.setFormatter(self.formatter)</span><br><span class="line">        <span class="keyword">return</span> filehandler</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出到控制台handler的函数定义</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_console_handler</span>(<span class="params">self</span>):</span></span><br><span class="line">        console_handler = logging.StreamHandler(sys.stdout)</span><br><span class="line">        console_handler.setFormatter(self.formatter)</span><br><span class="line">        <span class="keyword">return</span> console_handler</span><br></pre></td></tr></table></figure><p>那么使用这个类的方法可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> sef_def_logger <span class="keyword">import</span> MyLog</span><br><span class="line">my_logg = MyLog().logger</span><br><span class="line">my_logg.info(<span class="string">&quot;代码开始运行的时间&#123;&#125;&quot;</span>.<span class="built_in">format</span>(datetime.datetime.now()))</span><br><span class="line">my_logg.debug(<span class="string">&#x27;看看debug&#x27;</span>)</span><br><span class="line">my_logg.error(<span class="string">&#x27;This is a error&#x27;</span>)</span><br></pre></td></tr></table></figure><h3><span id="reference">Reference</span></h3><p><a href="https://docs.python.org/zh-cn/3/library/logging.html#module-logging">logging — Python的日志记录工具</a></p><p><a href="https://zhuanlan.zhihu.com/p/166671955">Python实用教程系列——Logging日志模块</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Logging库日志级别&quot;&gt;&lt;a href=&quot;#Logging库日志级别&quot; class=&quot;headerlink&quot; title=&quot;Logging库日志级别&quot;&gt;&lt;/a&gt;Logging库日志级别&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别&lt;/th&gt;
&lt;th&gt;级别数值&lt;/th&gt;
&lt;th&gt;使用时机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;DEBUG&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;详细信息，常用于调试&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INFO&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;程序正常运行过程中产生的一些信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WARNNING&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;警告用户，虽然程序还在正常工作，但有可能发生错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ERROR&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;由于更严重的问题，程序已不能执行一些功能了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CRITICAL&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;严重错误，程序已不能继续运行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;默认的日志级别是warning&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python多线程</title>
    <link href="http://example.com/2024/03/24/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2024/03/24/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-03-24T07:41:00.000Z</published>
    <updated>2024-04-02T16:24:34.751Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li><a href="#Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B">Python并发编程简介</a></li><li><a href="#%E6%80%8E%E6%A0%B7%E9%80%89%E6%8B%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E5%8D%8F%E7%A8%8B%EF%BC%9F">怎样选择多线程、多进程、多协程？</a></li><li><a href="#GIL%E9%94%81">GIL锁</a></li><li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8">多线程使用</a></li><li><a href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F">生产者-消费者模式</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3">线程安全问题和解决</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8web%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%8A%A0%E9%80%9F">线程池在web服务中实现加速</a></li><li><a href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8">多进程使用</a></li><li><a href="#%E5%BC%82%E6%AD%A5IO%EF%BC%9Aanyncio">异步IO：anyncio</a></li></ul><h3><span id="python并发编程简介">Python并发编程简介</span></h3><p>因为CPU和IO是可以同时并行执行的，IO的执行，比如读取内存、磁盘、网络他的过程中是不需要CPU的参与的。这样的话使用多线程CPU可以释放出来，来执行其他Task，实现并发加速</p><p>同理加入多进程就可以同时使用多个CPU来执行多个Task，来为我们的程序提速</p><span id="more"></span><p><img src="./1.png"></p><ul><li><p>多线程：threading，利用CPU和IO可以同时执行的原理，让CPU不会干巴巴的等待IO</p></li><li><p>多进程：multiprocessing，利用多核CPU的能力，真正的并行执行任务</p></li><li><p>异步IO：asyncio，在单线程利用CPU和IO同时执行的原理，实现函数异步执行</p></li><li><p>当多线程和进程同时访问同一个文件时，我们可以<code>使用Lock对资源加锁，防止冲突访问</code>，有序访问</p></li><li><p>使用Queue实现不同线程/进程之间的数据通信，实现生产者-消费者模式</p></li><li><p>使用线程池Pool/进程池Pool，简化线程/进程的任务提交、等待结束、获取结果</p></li><li><p>使用subprocess启动外部程序的进程，并进行输入输出交互（如：你写好了一个exe程序，那么使用这个模块就可以调起这个exe，并跟它进行输入输出的交互，来实现交互式的进程通信）</p></li></ul><h3><span id="怎样选择多线程-多进程-多协程">怎样选择多线程、多进程、多协程？</span></h3><ol><li>什么事CPU密集型（CPU-bound）计算、IO密集型（I/O-bound）计算</li></ol><p><code>CPU密集型</code>也叫计算密集型，是指I/O在很短时间就可以完成，CPU需要大量的计算和处理，特点是CPU占用率相当高</p><p>例如：压缩解压缩、加密解密、正则表达式搜索</p><p><code>I/O密集型</code>指的是系统运行大部分时间都是CPU在等I/O（硬盘/内存）的读/写操作，CPU占用率仍然较低</p><p>例如：文件处理程序、网络爬虫程序、读写数据库程序</p><ol start="2"><li>多线程、多进程、多协程对比</li></ol><p><code>多进程 Process（multiprocessing）</code></p><ul><li>优点：可以利用多核CPU并行计算</li><li>缺点：占用资源最多、可启动数目比线程少</li><li>适用于：CPU密集型计算</li></ul><p><code>多线程 Thread（threading）</code></p><ul><li>优点：相比进程，更轻量级、占用资源少</li><li>缺点：<ul><li>相比进程：多线程只能并发执行，不能利用多CPU（GIL）</li><li>相比协程：启动数目有限制，占用内存资源，有线程切换开销</li></ul></li><li>适用于：IO密集型计算、同时运行任务数目要求不多</li></ul><p><code>多协程 Coroutine（asyncio）</code></p><p>一个线程可以启动N个协程</p><ul><li>优点：内存开销最少、启动协程数量最多</li><li>缺点：支持的库有限制（aiohttp vs requests）、代码实现复杂</li><li>适用于：IO密集型计算、需要超多歌任务运行、但有现成库支持的场景</li></ul><h3><span id="gil锁">GIL锁</span></h3><ul><li>Python速度慢的两大原因</li><li>GIL是什么</li><li>为什么有GIL这个东西</li><li>怎样规避GIL带来的限制</li></ul><h4><span id="python速度慢的原因">Python速度慢的原因</span></h4><ul><li>动态类型语言，边解释边执行</li><li>有GIL锁存在，无法利用多核CPU并发执行</li></ul><h4><span id="gil是什么">GIL是什么</span></h4><p>全局解释器锁（Global Interpreter Lock）</p><p>是计算机程序设计语言解释器用于同步线程的一种机制，他使得任何时刻仅有一个线程在执行</p><p>即便在多核心处理器上，使用GIL的解释器也只允许同一时间执行一个线程</p><p><img src="./GIL.png"></p><h4><span id="为什么有gil这个东西">为什么有GIL这个东西</span></h4><p><code>简而言之：Python设计初期，为了规避并发问题引入了GIL，现在无法去除</code></p><p>为了解决多线程之间数据完整性和状态同步问题</p><p>Python中对象的管理，是使用引用计数器进行的，引用数0则释放对象</p><p>开始：线程A和线程B都引用了对象obj，obj.ref_num = 2，线程A和B都想撤销对obj的引用</p><p><img src="./GIL%E8%AF%A6%E8%A7%A3.png"></p><p>不过GIL简化了Python对共享资源的管理</p><h4><span id="怎样规避gil带来的限制">怎样规避GIL带来的限制？</span></h4><ol><li><p>多线程threading机制依然是有用的，用于IO密集型计算</p><p>因为在 I/O（read, write, send, recv, etc.）期间，线程会释放GIL，实现CPU和IO的并行</p><p><strong>因此多线程用于IO密集型计算依然可以大幅提升速度</strong></p><p><strong>但多线程用于CPU密集型计算时，只会更加拖慢速度</strong></p></li><li><p>使用<code>multiprocessing</code>的多进程机制实现并行计算、利用多核CPU优势</p><p>为了对应GIL的问题，Python提供了<code>multiprocessing</code></p></li></ol><h3><span id="多线程使用">多线程使用</span></h3><h4><span id="python-创建多线程方法">Python 创建多线程方法</span></h4><ol><li><p>准备一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    do_craw(a,b)</span><br></pre></td></tr></table></figure></li><li><p>怎样创建一个线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># target 传入一个函数</span></span><br><span class="line"><span class="comment"># args传的是一个元组</span></span><br><span class="line">t = threading.Thread(target=my_func, args=(<span class="number">100</span>,<span class="number">200</span>,) </span><br></pre></td></tr></table></figure></li><li><p>启动线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start()</span><br></pre></td></tr></table></figure></li><li><p>等待结束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.join()</span><br></pre></td></tr></table></figure></li></ol><h4><span id="使用简单的多线程爬虫">使用简单的多线程爬虫</span></h4><p><code>blog_spider.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">f&quot;https://www.cnblogs.com/#p<span class="subst">&#123;page&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">50</span> + <span class="number">1</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">craw</span>(<span class="params">url</span>):</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(url, <span class="built_in">len</span>(r.text))</span><br><span class="line"></span><br><span class="line"><span class="comment"># craw(urls[0])</span></span><br></pre></td></tr></table></figure><p><code>multi_thread_cray.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> blog_spider</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BenchmarkThread</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        self.end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;consume: <span class="subst">&#123;self.end - self.start&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_threaded_crawler</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start single thread crawling...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> blog_spider.urls:</span><br><span class="line">        blog_spider.craw(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end single thread crawling...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_threaded_crawler</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start multi thread crawling...&quot;</span>)</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> blog_spider.urls:</span><br><span class="line">        threads.append(</span><br><span class="line">            threading.Thread(target=blog_spider.craw, args=(url, ))</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end multi thread crawling...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> BenchmarkThread():</span><br><span class="line">        single_threaded_crawler()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> BenchmarkThread():</span><br><span class="line">        multi_threaded_crawler()</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">start single thread crawling...</span><br><span class="line">...</span><br><span class="line">https://www.cnblogs.com/<span class="comment">#p49 71620</span></span><br><span class="line">https://www.cnblogs.com/<span class="comment">#p50 71620</span></span><br><span class="line">end single thread crawling...</span><br><span class="line">consume: 17.035787105560303</span><br><span class="line"></span><br><span class="line">start multi thread crawling...</span><br><span class="line">...</span><br><span class="line">https://www.cnblogs.com/<span class="comment">#p12 71620</span></span><br><span class="line">https://www.cnblogs.com/<span class="comment">#p4 71620</span></span><br><span class="line">end multi thread crawling...</span><br><span class="line">consume: 1.0366919040679932</span><br></pre></td></tr></table></figure><p>可以看出多线程要快了17倍左右</p><h3><span id="生产者-消费者模式">生产者-消费者模式</span></h3><ul><li>多组件的Pipeline技术架构</li><li>生产者-消费者爬虫的架构</li><li>多线程数据通信的queue.Queue</li><li>代码编写实现生产者消费者爬虫</li></ul><h4><span id="多组件的pipline技术架构">多组件的Pipline技术架构</span></h4><p><img src="./Pipline.png"></p><h4><span id="生产者-消费值爬虫架构">生产者-消费值爬虫架构</span></h4><p><img src="./Producer-Consumer.png"></p><h4><span id="多线程数据通信的queuequeue">多线程数据通信的queue.Queue</span></h4><p>queue.Queue可以用于多线程之间的、<strong>线程安全</strong>的数据通信</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Queue</span></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">q.put(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元素</span></span><br><span class="line">item = q.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询状态</span></span><br><span class="line">q.qsize()<span class="comment"># 查看元素的多少</span></span><br><span class="line">q.empty()<span class="comment"># 判断是否为空</span></span><br><span class="line">q.full()<span class="comment"># 判断是否已满</span></span><br></pre></td></tr></table></figure><h4><span id="代码编写实现生产者消费者爬虫">代码编写实现生产者消费者爬虫</span></h4><p>modify <code>blog_spider.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> blog_spider</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fout</span>(<span class="params">file_path, data</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;a+&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="built_in">str</span>(data) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># producer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_craw</span>(<span class="params">url_queue: queue.Queue, html_queue: queue.Queue</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        url = url_queue.get()</span><br><span class="line">        html = blog_spider.craw(url)</span><br><span class="line">        html_queue.put(html)</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">f&quot;craw <span class="subst">&#123;url&#125;</span>&quot;</span>,</span><br><span class="line">              <span class="string">&quot;url_queue.size =&quot;</span>, url_queue.qsize())</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># consumer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_parse</span>(<span class="params">html_queue: queue.Queue, file_path</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        html = html_queue.get()</span><br><span class="line">        results = blog_spider.parse(html)</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            fout(file_path, result)</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name, <span class="string">f&quot;results.size&quot;</span>,</span><br><span class="line">              <span class="built_in">len</span>(results), <span class="string">&quot;html_queue.size =&quot;</span>, html_queue.qsize())</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_queue = queue.Queue()</span><br><span class="line">    html_queue = queue.Queue()</span><br><span class="line"></span><br><span class="line">    file_path = <span class="string">&#x27;./spider_data.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> blog_spider.urls:</span><br><span class="line">        url_queue.put(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># producer thread</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=do_craw, args=(url_queue, html_queue),</span><br><span class="line">                             name=<span class="string">f&quot;craw<span class="subst">&#123;idx&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># consumer thread</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        t = threading.Thread(target=do_parse, args=(html_queue, file_path),</span><br><span class="line">                             name=<span class="string">f&quot;parse<span class="subst">&#123;idx&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><h3><span id="线程安全问题和解决">线程安全问题和解决</span></h3><ul><li>线程安全概念介绍</li><li>Lock用于解决线程安全问题</li><li>实例代码演示问题以及解决方案</li></ul><h4><span id="线程安全概念介绍">线程安全概念介绍</span></h4><p>线程安全指某个函数、函数库在多线程环境中被调用时，能够正确处理多个线程之间的共享变量，使程序功能正确完成</p><p>由于线程的执行随时会发生切换，就造成了不可预料的结果，出现线程不安全</p><p>例如：两个线程先后进入 if 语句，第一个线程执行后，第二个线程也执行了（其实不应该执行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">account, amount</span>):</span></span><br><span class="line">    <span class="keyword">if</span> account.balance &gt;= amount:</span><br><span class="line">        account.balance -= amount</span><br></pre></td></tr></table></figure><p><img src="./thread_security.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, balance</span>):</span></span><br><span class="line">        self.balance = balance</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">account, amount</span>):</span></span><br><span class="line">    <span class="keyword">if</span> account.balance &gt;= amount:</span><br><span class="line">        time.sleep(<span class="number">0.1</span>) <span class="comment"># blocking can lead to thread switching </span></span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">              <span class="string">&quot;withdraw money successfully&quot;</span>)</span><br><span class="line">        account.balance -= amount</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">              <span class="string">&quot;balance&quot;</span>, account.balance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">              <span class="string">&quot;withdrawal failure insuffcient balance&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    account = Account(<span class="number">1000</span>)</span><br><span class="line">    ta = threading.Thread(target=draw, args=(account, <span class="number">800</span>), name=<span class="string">&quot;ta&quot;</span>)</span><br><span class="line">    tb = threading.Thread(target=draw, args=(account, <span class="number">800</span>), name=<span class="string">&quot;tb&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ta.start()</span><br><span class="line">    tb.start()</span><br></pre></td></tr></table></figure><p>结果1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tatb withdraw money successfully</span><br><span class="line">ta balance 200 withdraw money successfully</span><br><span class="line">tb balance -600</span><br></pre></td></tr></table></figure><h4><span id="lock用于解决线程安全问题">Lock用于解决线程安全问题</span></h4><p><img src="./solve_thread_security.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, balance</span>):</span></span><br><span class="line">        self.balance = balance</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">account, amount</span>):</span></span><br><span class="line">  <span class="keyword">with</span> lock: <span class="comment"># adding a lock to a thread</span></span><br><span class="line">      <span class="keyword">if</span> account.balance &gt;= amount:</span><br><span class="line">          time.sleep(<span class="number">0.1</span>) <span class="comment"># blocking can lead to thread switching </span></span><br><span class="line">          <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">                <span class="string">&quot;withdraw money successfully&quot;</span>)</span><br><span class="line">          account.balance -= amount</span><br><span class="line">          <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">                <span class="string">&quot;balance&quot;</span>, account.balance)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="built_in">print</span>(threading.current_thread().name,</span><br><span class="line">                <span class="string">&quot;withdrawal failure insuffcient balance&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    account = Account(<span class="number">1000</span>)</span><br><span class="line">    ta = threading.Thread(target=draw, args=(account, <span class="number">800</span>), name=<span class="string">&quot;ta&quot;</span>)</span><br><span class="line">    tb = threading.Thread(target=draw, args=(account, <span class="number">800</span>), name=<span class="string">&quot;tb&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ta.start()</span><br><span class="line">    tb.start()</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ta withdraw money successfully</span><br><span class="line">ta balance 200</span><br><span class="line">tb withdrawal failure insuffcient balance</span><br></pre></td></tr></table></figure><h3><span id="线程池">线程池</span></h3><ul><li>线程池的原理</li><li>使用线程池的好吃</li><li>ThreadPoolExecutor的使用语法</li><li>使用线程池改造爬虫程序</li></ul><p><font color="orange">使用线程池本身不需要加锁，但<strong>在访问和修改共享数据时可能需要使用锁</strong>或其他同步机制来确保线程安全</font></p><h4><span id="线程池的原理">线程池的原理</span></h4><p><img src="./threadPool_principle.png"></p><p>因为新建线程系统需要分配资源、终止线程系统需要回收资源</p><p>那么如果可以重用线程，则可以减去新建/终止的开销</p><p><img src="./threadPool.png"></p><p>线程池本身为提前预先建好的线程，这些线程会被重复的使用、</p><p>当有新任务时先放入任务队列，线程池里的线程会挨个取队列里的线程，依次执行</p><p>当没有任务时，回到线程池，并不会被销毁，等待下一个任务到来</p><h4><span id="使用线程池的好处">使用线程池的好处</span></h4><ol><li>提升性能：因为减去了大量新建、终止线程的开销，重用了线程资源</li><li>适用场景：适合处理突发性大量请求或需要大量线程完成的任务，但实际任务处理时间较短</li><li>防御功能：能有效避免系统因为创建线程过多，而导致系统负荷过大相应变慢等问题</li><li>代码优势：使用线程池的语法比自己新建线程执行线程更加简洁</li></ol><h4><span id="threadpoolexecutor的使用语法">ThreadPoolExecutor的使用语法</span></h4><p><img src="./ThreadPoolExecutor.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    results = pool.<span class="built_in">map</span>(craw, urls) <span class="comment"># 提前把urls都准备好，进行全部的执行</span></span><br><span class="line">    <span class="keyword">for</span> result im results:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>用法1：map 函数，很简单</p><p>注意 map 的结果和入参是顺序对应的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    futures = [pool.submit(craw, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures: <span class="comment"># 挨个等待每一个按顺序的结束，进行返回和打印</span></span><br><span class="line">        <span class="built_in">print</span>(future.result())</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures): <span class="comment"># 不管里面那个任务先执行完了，它就会先进行返回</span></span><br><span class="line">        <span class="built_in">print</span>(future.result())</span><br></pre></td></tr></table></figure><p>用法2：future模式，更强大</p><p>注意如果使用 as_completed 顺序是不定的</p><h4><span id="使用线程池改造爬虫程序">使用线程池改造爬虫程序</span></h4><p><code>thread_pool.py</code></p><p>使用<code>pool.map</code> 、 <code>futures</code>和<code>as_completed</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> blog_spider</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    htmls = pool.<span class="built_in">map</span>(blog_spider.craw, blog_spider.urls)</span><br><span class="line">    htmls = <span class="built_in">list</span>(<span class="built_in">zip</span>(blog_spider.urls, htmls))</span><br><span class="line">    <span class="keyword">for</span> url, html <span class="keyword">in</span> htmls:</span><br><span class="line">        <span class="built_in">print</span>(url, <span class="built_in">len</span>(html))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;craw over&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    futures = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> url, html <span class="keyword">in</span> htmls:</span><br><span class="line">        future = pool.submit(blog_spider.parse, html)</span><br><span class="line">        futures[future] = url</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> future, url <span class="keyword">in</span> futures.items():</span><br><span class="line">        <span class="built_in">print</span>(url, future.result())</span><br></pre></td></tr></table></figure><p><img src="./pool-map%E5%92%8Cfuture.png"></p><p>可以看出是顺序执行的，下面看看使用<code>futures.as_completed</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> blog_spider</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    htmls = pool.<span class="built_in">map</span>(blog_spider.craw, blog_spider.urls)</span><br><span class="line">    htmls = <span class="built_in">list</span>(<span class="built_in">zip</span>(blog_spider.urls, htmls))</span><br><span class="line">    <span class="keyword">for</span> url, html <span class="keyword">in</span> htmls:</span><br><span class="line">        <span class="built_in">print</span>(url, <span class="built_in">len</span>(html))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;craw over&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    futures = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> url, html <span class="keyword">in</span> htmls:</span><br><span class="line">        future = pool.submit(blog_spider.parse, html)</span><br><span class="line">        futures[future] = url</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> future, url <span class="keyword">in</span> futures.items():</span><br><span class="line">        <span class="built_in">print</span>(url, future.result())</span><br></pre></td></tr></table></figure><p><img src="./concurrent.futures.as_completed.png"></p><p>那个任务先执行完成，就先返回那个任务</p><p>总结</p><ul><li><code>pool.map</code>方式更加简洁，但你需要把所有的任务提前准备好，才能一次性提交。并且返回是按顺序返回的</li><li><code>pool.submit</code>方式是单个提交任务。<code>for future in futures</code>是按顺序返回的，而<code>for future in as_completed</code>那个任务先执行完成，就先返回那个</li><li>更推荐使用<code>for future in as_completed</code></li></ul><h3><span id="线程池在web服务中实现加速">线程池在web服务中实现加速</span></h3><ul><li>Web服务的架构以及特点</li><li>使用线程池ThreadPoolExecutor加速</li><li>代码使用Flask实现Web服务并实现加速</li></ul><h4><span id="web服务的架构以及特点">Web服务的架构以及特点</span></h4><p><img src="./Web%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%89%B9%E7%82%B9.png"></p><p>Web后台服务的特点</p><ul><li>Web服务对响应时间要求非常高，比如要求200ms内返回</li><li>Web服务有大量的依赖IO操作的调用，比如磁盘文件、数据库、远程API</li><li>Web服务经常需要处理几万人、几百万人的同时请求</li></ul><h4><span id="使用线程池threadpoolexecutor加速">使用线程池ThreadPoolExecutor加速</span></h4><p>使用线程池ThreadPoolExecutor的好处：</p><ul><li>方便的将磁盘文件、数据库、远程API的IO调用并发执行</li><li>线程池的线程数目不会无限创建（导致系统挂掉），具有防御功能</li></ul><h4><span id="代码使用flask实现web服务并实现加速">代码使用Flask实现Web服务并实现加速</span></h4><p><code>flask_thread_pool.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;read_file&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_db</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;read_db&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_api</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;read_api&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    result_file = read_file()</span><br><span class="line">    result_db = read_db()</span><br><span class="line">    result_api = read_api()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> json.dumps(&#123;</span><br><span class="line">        <span class="string">&quot;result_file&quot;</span>: result_file,</span><br><span class="line">        <span class="string">&quot;result_db&quot;</span>: result_db,</span><br><span class="line">        <span class="string">&quot;result_api&quot;</span>: result_api</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p><code>time curl http://127.0.0.1</code></p><p><img src="./time_curl.png"></p><p>可以看出每一次请求大概消耗600ms左右（三个IO操作，以及系统时间），那么这个程序我们如何改造和加速呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line">pool = ThreadPoolExecutor() <span class="comment"># 初始化全局线程池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;read_file&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_db</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;read_db&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_api</span>():</span></span><br><span class="line">    time.sleep(<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;read_api&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    result_file = pool.submit(read_file)</span><br><span class="line">    result_db = pool.submit(read_db)</span><br><span class="line">    result_api = pool.submit(read_api)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> json.dumps(&#123;</span><br><span class="line">        <span class="string">&quot;result_file&quot;</span>: result_file.result(),</span><br><span class="line">        <span class="string">&quot;result_db&quot;</span>: result_db.result(),</span><br><span class="line">        <span class="string">&quot;result_api&quot;</span>: result_api.result()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="./time_curl_improve.png"></p><p>为什么是300ms左右呢？因为他们并发同时运行时，花费最多的就是<code>read_api()</code>300ms，其他两个都在300ms内完成，所以请求花费时间基本等于最长消耗时间的函数了</p><h3><span id="多进程使用">多进程使用</span></h3><ul><li>有了多线程threading，为什么还要使用多进程multiprocessing</li><li>多进程mutiprocessing知识梳理（对比多线程threading）</li><li>单线程、多线程、多进程对CPU密集计算速度</li></ul><h4><span id="有了多线程threading为什么还要使用多进程multiprocessing">有了多线程threading，为什么还要使用多进程multiprocessing</span></h4><p><img src="./multiprocessing_issue.png"></p><p><strong><font color="orange">multiprocessing 模块就是python为了解决GIL缺陷引入的一个模块，原理是用多进程在多CPU上并行执行</font></strong></p><h4><span id="多进程mutiprocessing知识梳理">多进程mutiprocessing知识梳理</span></h4><p><img src="./%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86.png"></p><h4><span id="单线程-多线程-多进程cpu密集计算速度">单线程、多线程、多进程CPU密集计算速度</span></h4><p><img src="./%E5%8D%95%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8BCPU%E5%AF%86%E9%9B%86%E8%AE%A1%E7%AE%97%E9%80%9F%E5%BA%A6.png"></p><p><code>thread_process_cpu_bound.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math, time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">PRIMES = [<span class="number">112272535095293</span>] * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benchmark</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, description</span>):</span></span><br><span class="line">        self.description = description</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.start_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(self.description)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        self.end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;consume: <span class="subst">&#123;self.end_time - self.start_time&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sqrt_n = <span class="built_in">int</span>(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, sqrt_n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_thread</span>():</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> PRIMES:</span><br><span class="line">        is_prime(number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span>():</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        pool.<span class="built_in">map</span>(is_prime, PRIMES)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_process</span>():</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        pool.<span class="built_in">map</span>(is_prime, PRIMES)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> Benchmark(<span class="string">&quot;single thread&quot;</span>):</span><br><span class="line">        single_thread()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> Benchmark(<span class="string">&quot;multi thread&quot;</span>):</span><br><span class="line">        multi_thread()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> Benchmark(<span class="string">&quot;multi process&quot;</span>):</span><br><span class="line">        multi_process()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">single thread</span><br><span class="line">consume: 22.90883493423462</span><br><span class="line">multi thread</span><br><span class="line">consume: 22.713069915771484</span><br><span class="line">multi process</span><br><span class="line">consume: 4.842185974121094</span><br></pre></td></tr></table></figure><h4><span id="在flask服务中使用进程池加速">在Flask服务中使用进程池加速</span></h4><p><code>flask_process_pool.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask, math, json</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line">process_pool = ProcessPoolExecutor()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sqrt_n = <span class="built_in">int</span>(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, sqrt_n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/is_prime/&lt;numbers&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_is_prime</span>(<span class="params">numbers</span>):</span></span><br><span class="line">    number_list = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> numbers.split(<span class="string">&quot;,&quot;</span>)]</span><br><span class="line">    results = process_pool.<span class="built_in">map</span>(is_prime, number_list)</span><br><span class="line">    <span class="keyword">return</span> json.dumps(<span class="built_in">dict</span>(<span class="built_in">zip</span>(number_list, results)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    </span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请求路径<code>http://127.0.0.1:5000/is_prime/1,2,3,4</code></p><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;1&quot;</span>: <span class="literal">false</span>, <span class="string">&quot;2&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;3&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;4&quot;</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="异步ioanyncio">异步IO：anyncio</span></h3><p>在一个线程中如果遇到IO等待时间，线程不会傻傻等待，利用空闲的时候去干其他事情</p><p>语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">myfunc</span>(<span class="params">url</span>):</span></span><br><span class="line">  <span class="keyword">await</span> get_url(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建task列表</span></span><br><span class="line">tasks = [loop.create_task(myfunc(url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去生成或者获取一个事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将任务放到任务列表</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>要用在异步IO编程中，依赖的库必须支持异步IO特性</li><li>爬虫引用中：<code>requests</code> 不支持异步，需要用 <code>aiohttp</code></li></ol><p><img src="./%E5%8D%8F%E7%A8%8B.png"></p><p>python3.4及以后版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># 遇到IO耗时操作，自动切换到tasks中的其他任务</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line">tasks = [</span><br><span class="line">  asyncio.ensure_future(func1()),</span><br><span class="line">  asyncio.ensure_future(func2())</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><p>python3.5及以后版本（推荐），使用 anync &amp; await 关键字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># 遇到IO耗时操作，自动切换到tasks中的其他任务</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line">tasks = [</span><br><span class="line">  asyncio.ensure_future(func1()),</span><br><span class="line">  asyncio.ensure_future(func2())</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><p>使用协程异步保存文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">session, url</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;发送请求: &quot;</span>, url)</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">    content = <span class="keyword">await</span> response.content.read()</span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      f.write(content)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;下载完成: &quot;</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    url_list = [</span><br><span class="line">      <span class="string">&#x27;https://dailybing.com/view/zh-cn/20240109.html&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;https://dailybing.com/view/zh-cn/20240112.html&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;https://dailybing.com/view/zh-cn/20240113.html&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  asyncio.run(main())</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">发送请求:  https://dailybing.com/view/zh-cn/20240109.html</span><br><span class="line">发送请求:  https://dailybing.com/view/zh-cn/20240112.html</span><br><span class="line">发送请求:  https://dailybing.com/view/zh-cn/20240113.html</span><br><span class="line">下载完成:  https://dailybing.com/view/zh-cn/20240112.html</span><br><span class="line">下载完成:  https://dailybing.com/view/zh-cn/20240113.html</span><br><span class="line">下载完成:  https://dailybing.com/view/zh-cn/20240109.html</span><br></pre></td></tr></table></figure><h4><span id="python-异步io库介绍asyncio">Python 异步IO库介绍：asyncio</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">result = func()</span><br></pre></td></tr></table></figure><p><strong>执行协程函数创建的写成对象，函数内部代码不会执行</strong></p><p>如果想要运行协程函数内部代码，必须要将协程对象交给事件循环来处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  </span><br><span class="line">result = func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># loop = asyncio.get_event_loop()</span></span><br><span class="line"><span class="comment"># loop.run_until_complete(result) # 将函数添加到任务列表中</span></span><br><span class="line">asyncio.run(result) <span class="comment"># python 3.7及以后，代替上面两步</span></span><br></pre></td></tr></table></figure><h4><span id="await">await</span></h4><p><code>await</code> + 可等待的对象（协程对象、Future、Task对象 -&gt; IO等待）</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># IO等待</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>,response)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">others</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起任务时，事件循环可以去执行其他协程（任务）</span></span><br><span class="line">  response = <span class="keyword">await</span> others()</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;IO请求结束, 结果为: &quot;</span>, response)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行协程函数内部代码</span><br><span class="line">start</span><br><span class="line">end</span><br><span class="line">IO请求结束, 结果为:  返回值</span><br></pre></td></tr></table></figure><p><code>await</code>就是等待对象的值得到结果后再继续执行</p><h4><span id="task对象">Task对象</span></h4><blockquote><p>Tasks are used to schedule coroutines concurrently</p><p>When a coroutine is wrapped into a Task with functions like <code>asyncio.create_ task()</code> the coroutine is automatically scheduled to run soon.</p></blockquote><p>在事件循环中添加多个任务</p><p>Tasks 用于并发调度协程，通过<code>asyncio.create_task(协程对象)</code>的方式创建Task对象，这样可以让协程加入事件，循环中等待被调度执行。除了使用<code>asyncio.create_task()</code>函数以外（python3.7），还可以用低层级的<code>loop.create_task()</code>或<code>ensure_future()</code>函数（python3.7之前）。不建议手动实例化Task对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 创建Task对象，将当前执行func函数任务添加到事件循环中</span></span><br><span class="line">  task1 = asyncio.create_task(func())</span><br><span class="line">  task2 = asyncio.create_task(func())</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务</span></span><br><span class="line">  <span class="comment"># 此处的await是等待相对应的协程全都执行完毕并获取结果</span></span><br><span class="line">  ret1 = <span class="keyword">await</span> task1</span><br><span class="line">  ret2 = <span class="keyword">await</span> task2</span><br><span class="line">  <span class="built_in">print</span>(ret1, ret2)</span><br><span class="line">  </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">返回值 返回值</span><br></pre></td></tr></table></figure><p>简化写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 创建Task对象，将当前执行func函数任务添加到事件循环中</span></span><br><span class="line">  task_list = [</span><br><span class="line">    asyncio.create_task(func(), name=<span class="string">&#x27;n1&#x27;</span>),</span><br><span class="line">    asyncio.create_task(func(), name=<span class="string">&#x27;n2&#x27;</span>)</span><br><span class="line">  ]</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务</span></span><br><span class="line">  <span class="comment"># 此处的await是等待相对应的协程全都执行完毕并获取结果</span></span><br><span class="line"></span><br><span class="line">  done, pending = <span class="keyword">await</span> asyncio.wait(task_list, timeout=<span class="literal">None</span>) <span class="comment"># timeout 最多等待时间。 如果等待后未完成，pending返回一个未完成的集合</span></span><br><span class="line">  <span class="built_in">print</span>(done) <span class="comment"># 返回一个完成的集合</span></span><br><span class="line">  </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">&#123;&lt;Task finished name=&#x27;n1&#x27; coro=&lt;func() done, defined at test.py:3&gt; result=&#x27;返回值&#x27;&gt;, &lt;Task finished name=&#x27;n2&#x27; coro=&lt;func() done, defined at test.py:3&gt; result=&#x27;返回值&#x27;&gt;&#125;</span><br></pre></td></tr></table></figure><h4><span id></span></h4><h4><span id="asynciofuture对象">asyncio.Future对象</span></h4><blockquote><p>A <code>Future</code>is a special <strong>low-level</strong> awaitable object that represents an <strong>eventual result</strong> of an asynchronous operation.</p></blockquote><p>asyncio中的Future对象是一个相对更偏向底层的可对象，通常我们不会直接用到这个对象，而是直接使用Task对象来完成任务的并和状态的追踪。（ Task 是 Futrue的子类 ）</p><p>Future为我们提供了异步编程中的 最终结果 的处理（Task类也具备状态处理的功能）。</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 创建一个任务（Future对象），这个任务什么都不干。</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待任务最终结果（Future对象），没有结果则会一直等下去。</span></span><br><span class="line">    <span class="keyword">await</span> fut</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">set_after</span>(<span class="params">fut</span>):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    fut.set_result(<span class="string">&quot;666&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个任务（Future对象），没绑定任何行为，则这个任务永远不知道什么时候结束。</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个任务（Task对象），绑定了set_after函数，函数内部在2s之后，会给fut赋值。</span></span><br><span class="line">    <span class="comment"># 即手动设置future任务的最终结果，那么fut就可以结束了。</span></span><br><span class="line">    <span class="keyword">await</span> loop.create_task(set_after(fut))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待 Future对象获取 最终结果，否则一直等下去</span></span><br><span class="line">    data = <span class="keyword">await</span> fut</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>Future对象本身函数进行绑定，所以想要让事件循环获取Future的结果，则需要手动设置。而Task对象继承了Future对象，其实就对Future进行扩展，他可以实现在对应绑定的函数执行完成之后，自动执行<code>set_result</code>，从而实现自动结束。</p><p>虽然，平时使用的是Task对象，但对于结果的处理本质是基于Future对象来实现的。</p><p>扩展：支持 <code>await 对象</code>语 法的对象课成为可等待对象，所以 <code>协程对象</code>、<code>Task对象</code>、<code>Future对象</code> 都可以被成为可等待对象。</p><h4><span id="futuresfuture对象">futures.Future对象</span></h4><p><code>concurrent.futures.Future对象</code>使用线程池、进程池实现异步操作时用到的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> concurrent.futrues.thread <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futrues.process <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">value</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池</span></span><br><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程池</span></span><br><span class="line"><span class="comment"># pool = ProcessPoolExecutor(max_workers=5)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    fut = pool.submit(func, i)</span><br><span class="line">    <span class="built_in">print</span>(fut)</span><br></pre></td></tr></table></figure><p>两个Future对象是不同的，他们是为不同的应用场景而设计，例如：<code>concurrent.futures.Future</code>不支持await语法等</p><p>官方提示两对象之间不同：</p><ul><li>unlike asyncio Futures, <code>concurrent.futures.Future</code> instances cannot be awaited.</li><li><code>asyncio.Future.result()</code> and <code>asyncio.Future.exception()</code> do not accept the <em>timeout</em> argument.</li><li><code>asyncio.Future.result()</code> and <code>asyncio.Future.exception()</code> raise an <code>InvalidStateError</code> exception when the Future is not <em>done</em>.</li><li>Callbacks registered with <code>asyncio.Future.add_done_callback()</code> are not called immediately. They are scheduled with <code>loop.call_soon()</code> instead.</li><li>asyncio Future is not compatible with the <code>concurrent.futures.wait()</code> and <code>concurrent.futures.as_completed()</code> functions.</li></ul><p>在Python提供了一个将<code>futures.Future</code> 对象包装成<code>asyncio.Future</code>对象的函数 <code>asynic.wrap_future</code></p><p>一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果 <code>协程的异步</code>和 <code>进程池/线程池的异步</code> 混搭时，那么就会用到此功能了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="comment"># 某个耗时操作</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. Run in the default loop&#x27;s executor ( 默认ThreadPoolExecutor )</span></span><br><span class="line">    <span class="comment"># 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象</span></span><br><span class="line">    <span class="comment"># 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。</span></span><br><span class="line">    <span class="comment"># 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用。</span></span><br><span class="line">    fut = loop.run_in_executor(<span class="literal">None</span>, func1)</span><br><span class="line">    result = <span class="keyword">await</span> fut</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;default thread pool&#x27;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. Run in a custom thread pool:</span></span><br><span class="line">    <span class="comment"># with concurrent.futures.ThreadPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     result = await loop.run_in_executor(</span></span><br><span class="line">    <span class="comment">#         pool, func1)</span></span><br><span class="line">    <span class="comment">#     print(&#x27;custom thread pool&#x27;, result)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. Run in a custom process pool:</span></span><br><span class="line">    <span class="comment"># with concurrent.futures.ProcessPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     result = await loop.run_in_executor(</span></span><br><span class="line">    <span class="comment">#         pool, func1)</span></span><br><span class="line">    <span class="comment">#     print(&#x27;custom process pool&#x27;, result)</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h4><span id="asyncio-不支持异步模块">asyncio + 不支持异步模块</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_file</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 发送网络请求,下载文件(遇到网络下载文件IO请求,自动切换到其他任务)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始下载:&quot;</span>, url)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># requests模块默认不支持异步操作,所以使用线程池来配合实现</span></span><br><span class="line">    future = loop.run_in_executor(<span class="literal">None</span>, requests.get, url)</span><br><span class="line"></span><br><span class="line">    response = <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;下载完成:&quot;</span>, url)</span><br><span class="line">    <span class="comment"># 文件保存到本地</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(response.content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">&quot;https://dailybing.com/view/zh-cn/20240109.html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dailybing.com/view/zh-cn/20240110.html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dailybing.com/view/zh-cn/20240111.html&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    tasks = [download_file(url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1bK411A7tV?p=12&vd_source=7edae3cd790e850cc7836ab5c5d9ac4b">https://www.bilibili.com/video/BV1bK411A7tV?p=12&amp;vd_source=7edae3cd790e850cc7836ab5c5d9ac4b</a></p><p><a href="https://www.dabeaz.com/python/UnderstandingGIL.pdf">Understanding GIL</a></p><p><a href="https://zhuanlan.zhihu.com/p/354358309">https://zhuanlan.zhihu.com/p/354358309</a></p><p><a href="https://docs.python.org/zh-cn/3.9/library/asyncio-task.html">https://docs.python.org/zh-cn/3.9/library/asyncio-task.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/137057192">https://zhuanlan.zhihu.com/p/137057192</a></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B&quot;&gt;Python并发编程简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%8E%E6%A0%B7%E9%80%89%E6%8B%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E5%8D%8F%E7%A8%8B%EF%BC%9F&quot;&gt;怎样选择多线程、多进程、多协程？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#GIL%E9%94%81&quot;&gt;GIL锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8&quot;&gt;多线程使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F&quot;&gt;生产者-消费者模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3&quot;&gt;线程安全问题和解决&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BA%BF%E7%A8%8B%E6%B1%A0&quot;&gt;线程池&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8web%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%8A%A0%E9%80%9F&quot;&gt;线程池在web服务中实现加速&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8&quot;&gt;多进程使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BC%82%E6%AD%A5IO%EF%BC%9Aanyncio&quot;&gt;异步IO：anyncio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Python并发编程简介&quot;&gt;&lt;a href=&quot;#Python并发编程简介&quot; class=&quot;headerlink&quot; title=&quot;Python并发编程简介&quot;&gt;&lt;/a&gt;Python并发编程简介&lt;/h3&gt;&lt;p&gt;因为CPU和IO是可以同时并行执行的，IO的执行，比如读取内存、磁盘、网络他的过程中是不需要CPU的参与的。这样的话使用多线程CPU可以释放出来，来执行其他Task，实现并发加速&lt;/p&gt;
&lt;p&gt;同理加入多进程就可以同时使用多个CPU来执行多个Task，来为我们的程序提速&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>pytest-Allure</title>
    <link href="http://example.com/2024/03/12/pytest-Allure/"/>
    <id>http://example.com/2024/03/12/pytest-Allure/</id>
    <published>2024-03-12T14:19:53.000Z</published>
    <updated>2024-03-18T09:51:43.603Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3><span id="allure报告结构">Allure报告结构</span></h3><ul><li><p>Overview:整体数据显示。</p></li><li><p>Suites:用例集合,按照套件和类分组的已执行测试的标准结构表示形式。</p></li><li><p>Behaviors：对于行为驱动的方法，此选项卡根据Epic、Feature和Story标记对测试结果进行分组。</p></li><li><p>Categories：“类别”选项卡提供了创建自定义缺陷分类以应用测试结果的方法。</p></li><li><p>Graphs：用图表显示测试数据中收集的不同统计数据，状态分解或严重性和持续时间图。</p></li><li><p>Packages：软件包选项卡表示测试结果的树状布局，按不同的包名分组。</p></li><li><p>Timeline：时间轴选项卡可视化测试执行的回顾，allure适配器收集测试的精确时间，在这个选项卡上，它们相应地按照顺序或并行的时间结构排列。</p></li></ul><span id="more"></span><h3><span id="allure安装">Allure安装</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install allure-pytest</span><br></pre></td></tr></table></figure><ol><li>下载 allure ZIP包 <code>https://github.com/allure-framework/allure2/releases</code></li><li><code>pip install pytest-allure</code></li><li><code>vim ~/.zshrc</code> 并在最后一行添加环境变量 <code>export PATH=&quot;/Users/william/DYJ/Tools/allure-2.7.0/bin:$PATH&quot;</code></li><li>使环境变量生效 <code>source ~/.zshrc</code></li><li>验证 <code>allure --version</code></li></ol><h3><span id="allure基本用法">Allure基本用法</span></h3><ul><li><code>@allure.epic():</code> 项目名称</li><li><code>@allure.feature():</code> 模块名称，功能点描述</li><li><code>@allure.story():</code> 接口名称</li><li><code>@allure.title():</code> 测试用例标题（适用于一个方法对应一个用例）</li><li><code>allure.dynamic.title:</code> 测试用例标题（适用于一个方法对应多个用例，用于数据驱动情况）</li><li><code>@allure.testcase():</code> 关联测试用例系统里面的用例</li><li><code>@allure.issue():</code> 关联缺陷管理系统里面的链接</li><li><code>@allure.description:</code> 测试用例的描述</li><li><code>@allure.step():</code> 测试用例的步骤</li><li><code>@allure.severity():</code> 用例的等级（block、critical、normal、minor、trivial）</li><li><code>@allure.link():</code> 定义一个链接，在测试报告中展现</li><li><code>@allure.attachment():</code> 为测试报告添加附件</li></ul><h3><span id="allure-epicfeaturestorytitle">Allure epic/feature/story/title</span></h3><ol><li><p>编辑<code>./testcase/alluredemo/test_allure.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> allure</span><br><span class="line"></span><br><span class="line"><span class="meta">@allure.epic(<span class="params"><span class="string">&quot;接口项目名称：xx在线接口测试&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@allure.feature(<span class="params"><span class="string">&quot;接口模块名称：IVR接口&quot;</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApi</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.story(<span class="params"><span class="string">&quot;接口名称：常规请求&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.title(<span class="params"><span class="string">&quot;@allure.title 测试用例1&quot;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_allure_01</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test_allure_01&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.title(<span class="params"><span class="string">&quot;@allure.title 测试用例2&quot;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_allure_02</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test_allure_02&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改<code>pytest.ini</code>文件中的<code>addopts</code>参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[pytest]</span><br><span class="line"><span class="comment">#--html ./report/report.html，reruns 失败重跑次数</span></span><br><span class="line"><span class="comment"># addopts = -vs -n=2 -reruns 2 --html ./report/report.html</span></span><br><span class="line"><span class="comment"># 生成json格式的allure报告，并删除上一次的报告</span></span><br><span class="line">addopts = -vs --alluredir=reports/temps --clean-alluredir</span><br><span class="line"><span class="comment"># 指定 pytest 搜索测试文件的路径。pytest 将在 ./interfaceCase 目录下搜索可执行文件</span></span><br><span class="line">testpaths =</span><br><span class="line">    ./testcase/alluredemo</span><br><span class="line"><span class="comment"># 指定 pytest 应该匹配的测试文件模式。pytest 将会运行所有以 test_ 为开头的 python 文件</span></span><br><span class="line">python_files = test_*.py</span><br><span class="line"><span class="comment"># 指定 pytest 应该匹配的测试类名模式。pytest 将会运行所有以 Test 开头的类</span></span><br><span class="line">python_classes = Test</span><br><span class="line"><span class="comment"># 指定 pytest 应该匹配的测试函数模式。pytest 将会运行所有以 Test 开头的函数</span></span><br><span class="line">python_functions = test</span><br><span class="line"><span class="comment"># 用于为测试用例添加标记。使用方法: @pytest.mark.smoke  pytest -m &quot;smoke [or usermanage]&quot;</span></span><br><span class="line">markers =</span><br><span class="line">    smoke : Smoke Testing Module</span><br><span class="line">    userManage : User Management Module</span><br><span class="line">    productManage : 商品管理</span><br></pre></td></tr></table></figure></li><li><p><code>main.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main()</span><br><span class="line">    time.sleep(<span class="number">1</span>) <span class="comment"># 生成报告需要一点时间</span></span><br><span class="line">    os.system(<span class="string">&#x27;allure generate ./reports/temps -o ./reports/allures --clean&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>allure generate</code> 固定写法</li><li><code>./reports/temps</code>: 临时的 json 格式报告的路径</li><li><code>-o</code>: 输出 output</li><li><code>./reports/allure</code>: 生成的 allure 报告的路径</li><li><code>--clean</code>: 清空<code>./report</code> 路径原来的报告</li></ul></li><li><p>结果</p><p><img src="./allure1.jpg"></p></li></ol><h3><span id="allure-severitydescription">Allure severity/description</span></h3><ul><li>Blocker</li><li>Critical</li><li>Normal</li><li>Minor</li><li>Trivial</li></ul><p><code>@allure.severity(allure.serverity_level.BLOCKER)</code></p><p><font color="orange">这个装饰器既可以修饰方法，也可以修饰类</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> allure</span><br><span class="line"></span><br><span class="line"><span class="meta">@allure.epic(<span class="params"><span class="string">&quot;接口项目名称：xx在线接口测试&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@allure.feature(<span class="params"><span class="string">&quot;接口模块名称：IVR接口&quot;</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApi</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.story(<span class="params"><span class="string">&quot;接口名称：常规请求&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.title(<span class="params"><span class="string">&quot;@allure.title 测试用例1&quot;</span></span>) </span><span class="comment"># 单次的用例标题</span></span><br><span class="line"><span class="meta">    @allure.description(<span class="params"><span class="string">&quot;@allure.description: 测试用例描述&quot;</span></span>) </span><span class="comment"># 单次的用例描述</span></span><br><span class="line"><span class="meta">    @allure.severity(<span class="params">allure.severity_level.BLOCKER</span>) </span><span class="comment"># 单次的用例优先级</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_allure_01</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test_allure_01&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.title(<span class="params"><span class="string">&quot;@allure.title 测试用例2&quot;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_allure_02</span>(<span class="params">self</span>):</span></span><br><span class="line">        allure.dynamic.title(<span class="string">&quot;allure.dynamic.title&quot;</span>) <span class="comment"># 用于数据驱动的标题</span></span><br><span class="line">        allure.dynamic.description(<span class="string">&quot;allure.dynamic.description&quot;</span>) <span class="comment"># 用于数据驱动的用例描述</span></span><br><span class="line">        allure.dynamic.severity(allure.severity_level.BLOCKER) <span class="comment"># 用于数据驱动的用例优先级</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test_allure_02&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="./severity.jpg"></p><h3><span id="allure-linkissuetestcase">Allure link/issue/testcase</span></h3><ul><li><code>@allure.description()</code>: 用例描述</li><li><code>@allure.link(url, name=name)</code>: 接口地址</li><li><code>@allure.issue(url, name=name)</code>: BUG链接</li><li><code>@allure.testcase(url, name=name)</code>: 测试用例地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> allure</span><br><span class="line"></span><br><span class="line"><span class="meta">@allure.epic(<span class="params"><span class="string">&quot;接口项目名称：xx在线接口测试&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@allure.feature(<span class="params"><span class="string">&quot;接口模块名称：DM接口&quot;</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApi</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.story(<span class="params"><span class="string">&quot;接口名称：数据驱动测试&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @pytest.mark.parametrize(<span class="params"><span class="string">&quot;test_case_title, link&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">                             [[<span class="string">&quot;allure.dynamic.title 测试用例1&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>],</span></span></span><br><span class="line"><span class="params"><span class="meta">                              [<span class="string">&quot;allure.dynamic.title 测试用例2&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>],</span></span></span><br><span class="line"><span class="params"><span class="meta">                              [<span class="string">&quot;allure.dynamic.title 测试用例3&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>]]</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_allure_03</span>(<span class="params">self, test_case_title, link, user_fixture</span>):</span></span><br><span class="line">        allure.dynamic.title(test_case_title)</span><br><span class="line">        allure.dynamic.severity(allure.severity_level.BLOCKER)</span><br><span class="line">        allure.dynamic.description(test_case_title)</span><br><span class="line">        allure.dynamic.link(url=link, name=<span class="string">&quot;API URL&quot;</span>)</span><br><span class="line">        <span class="comment"># 测试用例步骤</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">with</span> allure.step(<span class="string">&quot;测试用例步骤&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&quot;</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;步骤&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;执行脚本&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="./description.jpg"></p><h3><span id="使用yaml作为数据驱动">使用YAML作为数据驱动</span></h3><ul><li><code>allure.attach(file_path, name=None, attachment_type=None)</code>: 附件</li></ul><p><code>attachment_type=allure.AttachmentType.TEXT</code>类型：</p><ol><li><strong>TEXT</strong> - 文本内容。用于附加简单的文本信息。</li><li><strong>PNG</strong> - PNG 图片格式。用于附加截图或其他 PNG 图片。</li><li><strong>JPG</strong> - JPG 图片格式。用于附加 JPG 格式的图片。</li><li><strong>GIF</strong> - GIF 图片格式。用于附加 GIF 图片。</li><li><strong>HTML</strong> - HTML 内容。用于附加 HTML 格式的内容，可以在报告中渲染为富文本。</li><li><strong>XML</strong> - XML 格式内容。用于附加 XML 文件或内容。</li><li><strong>JSON</strong> - JSON 格式内容。用于附加 JSON 文件或内容。</li><li><strong>CSV</strong> - CSV 格式内容。用于附加 CSV 文件或内容。</li><li><strong>TXT</strong> - 文本文件。与 TEXT 类似，但更强调是文件形式。</li></ol><p><code>test_allure.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">获取token接口</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">接口描述</span></span><br><span class="line">  <span class="attr">severity:</span> <span class="string">BLOCKER</span></span><br><span class="line">  <span class="attr">request:</span></span><br><span class="line">    <span class="attr">method:</span> <span class="string">get</span></span><br><span class="line">    <span class="attr">url_name:</span> <span class="string">&quot;bing search&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://cn.bing.com/search?/</span></span><br><span class="line">    <span class="attr">data:</span></span><br><span class="line">      <span class="attr">q:</span> <span class="string">&quot;安娜卡列尼娜&quot;</span></span><br><span class="line">  <span class="attr">validate:</span> <span class="string">None</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">获取token接口</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">接口描述</span></span><br><span class="line">  <span class="attr">severity:</span> <span class="string">CRITICAL</span></span><br><span class="line">  <span class="attr">request:</span></span><br><span class="line">    <span class="attr">method:</span> <span class="string">get</span></span><br><span class="line">    <span class="attr">url_name:</span> <span class="string">&quot;bing search&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://cn.bing.com/search?/</span></span><br><span class="line">    <span class="attr">data:</span></span><br><span class="line">      <span class="attr">q:</span> <span class="string">&quot;平凡的世界&quot;</span></span><br><span class="line">  <span class="attr">validate:</span> <span class="string">None</span></span><br></pre></td></tr></table></figure><p><code>test_allure.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> allure</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YamlUntil</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, yaml_file</span>):</span></span><br><span class="line">        self.yaml_file = yaml_file</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_yaml</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.yaml_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data = yaml.load(f, Loader=yaml.FullLoader)</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_severity_level</span>(<span class="params">severity_string</span>):</span></span><br><span class="line">    severity_mapping = &#123;</span><br><span class="line">        <span class="string">&quot;BLOCKER&quot;</span>: allure.severity_level.BLOCKER,</span><br><span class="line">        <span class="string">&quot;CRITICAL&quot;</span>: allure.severity_level.CRITICAL,</span><br><span class="line">        <span class="string">&quot;NORMAL&quot;</span>: allure.severity_level.NORMAL,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 通过get获取对应的值，默认为...NORMAL</span></span><br><span class="line">    <span class="keyword">return</span> severity_mapping.get(severity_string, allure.severity_level.NORMAL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@allure.epic(<span class="params"><span class="string">&quot;接口项目名称：xx在线接口测试&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@allure.feature(<span class="params"><span class="string">&quot;接口模块名称：DM接口&quot;</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApi</span>:</span></span><br><span class="line"></span><br><span class="line">    yaml_path = os.getcwd() + <span class="string">&quot;/testcase/alluredemo/test_allure.yaml&quot;</span></span><br><span class="line">    yaml_file = YamlUntil(yaml_path).read_yaml()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.story(<span class="params"><span class="string">&quot;接口名称：数据驱动测试&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @pytest.mark.parametrize(<span class="params"><span class="string">&quot;caseinfo&quot;</span>, yaml_file</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_allure_03</span>(<span class="params">self, caseinfo, user_fixture</span>):</span></span><br><span class="line">        <span class="comment">#print(caseinfo)</span></span><br><span class="line">        allure.dynamic.title(caseinfo[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">        severity_level = get_severity_level(caseinfo[<span class="string">&quot;severity&quot;</span>])</span><br><span class="line">        <span class="comment">#print(severity_level)</span></span><br><span class="line">        allure.dynamic.severity(severity_level)</span><br><span class="line">        allure.dynamic.description(caseinfo[<span class="string">&quot;description&quot;</span>])</span><br><span class="line">        allure.dynamic.link(url=caseinfo[<span class="string">&quot;request&quot;</span>][<span class="string">&quot;url&quot;</span>], name=caseinfo[<span class="string">&quot;request&quot;</span>][<span class="string">&quot;url_name&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># allure.attach 可以二次封装</span></span><br><span class="line">        allure.attach(body=caseinfo[<span class="string">&quot;request&quot;</span>][<span class="string">&quot;url&quot;</span>], name=<span class="string">&quot;请求地址: &quot;</span>, attachment_type=allure.attachment_type.TEXT)</span><br><span class="line">        allure.attach(body=caseinfo[<span class="string">&quot;request&quot;</span>][<span class="string">&quot;method&quot;</span>], name=<span class="string">&quot;请求方式: &quot;</span>, attachment_type=allure.attachment_type.TEXT)</span><br><span class="line">        data = caseinfo[<span class="string">&quot;request&quot;</span>][<span class="string">&quot;data&quot;</span>]</span><br><span class="line">        allure.attach(body=json.dumps(data), name=<span class="string">&quot;请求数据: &quot;</span>, attachment_type=allure.attachment_type.TEXT)</span><br><span class="line">        res = requests.get(url=caseinfo[<span class="string">&quot;request&quot;</span>][<span class="string">&quot;url&quot;</span>], params=data)</span><br><span class="line">        allure.attach(body=res.text, name=<span class="string">&quot;响应数据&quot;</span>, attachment_type=allure.attachment_type.TEXT)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 测试用例步骤</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">with</span> allure.step(<span class="string">&quot;测试用例步骤&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&quot;</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;步骤&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;执行脚本&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="./attach.jpg"></p><h3><span id="reference">Reference</span></h3><p>[1] <a href="https://allurereport.org/docs/">https://allurereport.org/docs/</a></p><p>[2] <a href="https://zhuanlan.zhihu.com/p/555114726">https://zhuanlan.zhihu.com/p/555114726</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Allure报告结构&quot;&gt;&lt;a href=&quot;#Allure报告结构&quot; class=&quot;headerlink&quot; title=&quot;Allure报告结构&quot;&gt;&lt;/a&gt;Allure报告结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Overview:整体数据显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Suites:用例集合,按照套件和类分组的已执行测试的标准结构表示形式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Behaviors：对于行为驱动的方法，此选项卡根据Epic、Feature和Story标记对测试结果进行分组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Categories：“类别”选项卡提供了创建自定义缺陷分类以应用测试结果的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Graphs：用图表显示测试数据中收集的不同统计数据，状态分解或严重性和持续时间图。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Packages：软件包选项卡表示测试结果的树状布局，按不同的包名分组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Timeline：时间轴选项卡可视化测试执行的回顾，allure适配器收集测试的精确时间，在这个选项卡上，它们相应地按照顺序或并行的时间结构排列。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="自动化测试" scheme="http://example.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="pytest" scheme="http://example.com/tags/pytest/"/>
    
  </entry>
  
</feed>
