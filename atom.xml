<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蒙珣的博客</title>
  
  <subtitle>未来很长，当有勇气面对，当与自己和解。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-12T04:42:09.218Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>蒙珣</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《葬》观后感</title>
    <link href="http://example.com/2021/12/12/%E3%80%8A%E8%91%AC%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    <id>http://example.com/2021/12/12/%E3%80%8A%E8%91%AC%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</id>
    <published>2021-12-12T04:16:47.000Z</published>
    <updated>2021-12-12T04:42:09.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>《葬》观后感</p><blockquote><p>本片讲述了一个农村老太太在70岁大寿的时候，想让自己多年不见的儿子和小孙子回家，结果通知了两个儿子都没人回来，老太太就联合自己的女儿来了一场假死闹剧，结果两个儿子回家，一个着急走，一个急着分家产，这让老人伤透了心，而小孙子很孝顺却意外导致了老人的死亡。小孙子在奶奶死后也喜欢上了戏曲，但是小峰的妈妈却极力反对，看到戏曲的没落和家庭矛盾愈演愈烈，小孙子的情感和愿望也在不断被压制…….</p></blockquote><p>在B站偶然刷到了这部节选影片，可以看出来导演想要表达的东西有很多，通过大量对比的手法呈现给观众，可惜只有30分钟的影片无法承载这么大的内容，导致了影片讲述内容出现了杂而多的情况。什么都想讲，但又好像什么都没有讲，这也造成了影片中心思想没有突出的展示。</p><span id="more"></span><p>影片刚开始是家庭的破碎，妻子坐在屋内，丈夫将手中的离婚协议书撕碎，小峰穿过两人。这里可以看出，家庭出现了问题，一家三口都是独立的个体。妻子想要离婚，结束这段痛苦的过程，小峰没有支持谁，也没有反对，而是默然走过，像是许可了一切。丈夫从后面可以知道，他还有另外一个家庭，这也是妻子想要离婚的根本原因。但是为什么要撕碎离婚协议书呢？难道是为了面子吗？因为在后面可以看出他逃出农村后事业有成，可能是不想被人抓住把柄。</p><p>接着就是他们奔丧路上的桥段。小峰带上耳机没有听父亲放的戏曲，代表了他不喜欢戏曲文化，也体现了他对亲情的冷漠。小峰妈妈给丈夫喂香蕉，是否可以看出她其实不想离婚，还想维持这个家庭，离婚协议书也是无奈之举，不过丈夫并没有吃。这与之前撕碎离婚协议书形成了对比，与人物矛盾。小峰与家庭的矛盾，妻子与丈夫的矛盾。这里影片还没有说小峰与家庭的矛盾是什么，这也算是一条暗线。</p><p>回到农村后，从帮弟弟看车可以看出哥哥的虚荣心，很好的体现了小农村人民的市侩。当然这样的对比也在后面弟弟出钱准备丧事，哥哥想赚丧葬费有所体现。</p><p>当兄妹三人商讨丧葬事宜的时候，弟弟想的是尽快下葬，哥哥想的是丧葬要隆重，姐姐想的是不要通知村里人，先商讨清楚丧葬事情。这里可以看出他们兄妹三人的家庭观念也是各行其道，在家庭中每个人也是一个独立的个体，与小峰的小家庭呈现了映照。</p><p>弟弟想要尽快下葬，从之前看到母亲灵体哭丧而被工作电话打断可以看出，他对这个农村家庭其实是没有多少留念的，可以说他的下跪是给家人们看的，也可以说他是给这个社会看的，给他自己看的，想要维持这份表面上的礼，就像他撕碎了离婚协议书一样。影片中弟弟哭丧与电话中的欢喜的彩铃是导演做的众多戏剧冲突的一个，荒诞却又那么的现实。</p><p>哥哥想要举办隆重的葬礼，是为了能多捞丧葬费，这个不难看出。从开头的虚荣心，到之后的串通桑队，再到分房，以及奶奶口中的话也有体现。</p><p>不过姐姐这个人物个人认为没有表现得很到位，不知道是不是影片时长的原因。从开头与她娘设计让兄弟二人回家，到后来给她妈宽心多想想自己的好孙子。都体现出她想推动这个家的团结，或者说想要完成妈妈的心愿。当他们三人在屋外商讨丧葬事宜的时候，不通知乡里乡亲，也不下葬就表明了这次死亡有问题，当然至亲之人的去世，她脸上没有什么悲伤的情绪也可以说明此问题。</p><p>小峰对着奶奶的遗体认真的磕头，那种单纯与他的爸爸叔叔形成了对比。之后小峰找到了儿时青梅，双方的腼腆，话语间能说的只有儿时的回忆展现了她们之间已经山海相隔。</p><p>那句“你喜欢他吗？”</p><p>圆圆回答的却是</p><p>“他在镇上修车一个月不少赚呢！”</p><p>以及“22岁才刚大学毕业，还要找工作”</p><p>道出了农村的婚姻观念，与小峰向往的婚姻自由。回到农村的小峰熟悉的也只有儿时的记忆，从问路，到聊过去，再到在奶奶灵堂前说想回到小时候，一切已是物是人非。</p><p>影片的高潮在于小峰“误将”棺材盖盖而憋死了奶奶，其实当他为奶奶擦泪的时候已经就明白了奶奶假死，而奶奶假戏真做也说明了真心求死的心。不过这点其实我不能有所共鸣，很多人其实不太能理解，就算亲人真的想求死，但我们真的能下得去手吗，何况是这个世界上对自己最好的人？</p><p>当超现实中奶奶为小峰再唱一曲，与小峰最后的一抹微笑，像是体现两人的解脱。</p><p>农村的艳舞桥段，兄妹三人灵堂后打牌的桥段，小峰最后对葬礼上戏曲的痴迷，也诠释了他的单纯的心。说姐姐这个角色没有体现好是因为，后面出现了灵堂打牌，没有把弟妹当一家人。似乎她也不是很在乎，与之前为妈设计有冲突。如果往黑暗的一面想，她或许也是想分一份家产。</p><p>最让我震撼的是小峰最后在黄昏唱着《小仓娃》，戏曲声音哀婉动人。但圆圆却在坟前跳着现代舞曲，能看出来他们中有一个人不是真的在。也许圆圆是假的，代表了小峰怀念的圆圆，他走上了戏曲的道路，但没必要放着现代舞曲。或许小峰是假的，或者说他已经不在了，但圆圆也没必要在坟前跳舞吧。</p><p>小峰向往的自由与理想，在家人面前格格不入，与《月亮与六便士》有异曲同工之处。追求理想的过程中需要放弃一些重要的东西。我妈在看完这部短片后，也和小峰妈妈一样说不该学戏曲。</p><p>人生的理想到底该由社会决定，还是由我们自己呢？我会努力最求后者。</p><p>尽管30分钟的影片确实因为想要表达的内容太多而导致内容杂碎了，但也不失这是一部很好的影片，期待这部电影长片以及导演的其他作品。</p><p><img src="1.png"></p><p><small>2021.12.12 国家图书馆</small></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://www.bilibili.com/video/BV1Lg411N7YV"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;《葬》观后感&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本片讲述了一个农村老太太在70岁大寿的时候，想让自己多年不见的儿子和小孙子回家，结果通知了两个儿子都没人回来，老太太就联合自己的女儿来了一场假死闹剧，结果两个儿子回家，一个着急走，一个急着分家产，这让老人伤透了心，而小孙子很孝顺却意外导致了老人的死亡。小孙子在奶奶死后也喜欢上了戏曲，但是小峰的妈妈却极力反对，看到戏曲的没落和家庭矛盾愈演愈烈，小孙子的情感和愿望也在不断被压制…….&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在B站偶然刷到了这部节选影片，可以看出来导演想要表达的东西有很多，通过大量对比的手法呈现给观众，可惜只有30分钟的影片无法承载这么大的内容，导致了影片讲述内容出现了杂而多的情况。什么都想讲，但又好像什么都没有讲，这也造成了影片中心思想没有突出的展示。&lt;/p&gt;</summary>
    
    
    
    <category term="佳片分享" scheme="http://example.com/categories/%E4%BD%B3%E7%89%87%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="2021" scheme="http://example.com/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>python 递归</title>
    <link href="http://example.com/2021/12/07/python-%E9%80%92%E5%BD%92/"/>
    <id>http://example.com/2021/12/07/python-%E9%80%92%E5%BD%92/</id>
    <published>2021-12-07T14:58:11.000Z</published>
    <updated>2021-12-07T15:22:40.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归的两个特点：</p><ul><li>调用自身</li><li>结束条件</li></ul><span id="more"></span><h4 id="两个递归实例："><a href="#两个递归实例：" class="headerlink" title="两个递归实例："></a>两个递归实例：</h4><p><strong>先打印结果再调用自身</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">x</span>):</span></span><br><span class="line">  <span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    func1(x-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">func1(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>先调用自身再打印结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">x</span>):</span></span><br><span class="line">  <span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line">  func2(x-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    </span><br><span class="line">func2(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="汉诺塔（hanoi）"><a href="#汉诺塔（hanoi）" class="headerlink" title="汉诺塔（hanoi）"></a>汉诺塔（hanoi）</h4><p><img src="hanoi.png"></p><p><strong>思考</strong></p><p>n个盘子时：</p><ol><li>把n-1个盘子从A经过C移动到B</li><li>把第n个盘子从A移动到C</li><li>把n-1个小盘子从B经过A移动到C</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># n个盘子，a、b、c三个柱子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span>(<span class="params">n,a,b,c</span>):</span></span><br><span class="line">  <span class="comment"># 盘子的数量大于0，不然就减成负数了</span></span><br><span class="line">  <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 我们会通过很多步骤讲n-1个盘子经过c柱子移动到b柱子上</span></span><br><span class="line">    hanoi(n-<span class="number">1</span>,a,c,b)</span><br><span class="line">    <span class="comment"># 再将最底下的盘子n移动到c上</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;moving form %s to %s&quot;</span> % (a,c))</span><br><span class="line">    <span class="comment"># 再将b柱子上的盘子经过a移动到c上</span></span><br><span class="line">    hanoi(n-<span class="number">1</span>,b,a,c)</span><br><span class="line"> </span><br><span class="line">hanoi(<span class="number">3</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">moving <span class="keyword">from</span> A to C</span><br><span class="line">moving <span class="keyword">from</span> A to B</span><br><span class="line">moving <span class="keyword">from</span> C to B</span><br><span class="line">moving <span class="keyword">from</span> A to C</span><br><span class="line">moving <span class="keyword">from</span> B to A</span><br><span class="line">moving <span class="keyword">from</span> B to C</span><br><span class="line">moving <span class="keyword">from</span> A to C</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h3&gt;&lt;p&gt;递归的两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用自身&lt;/li&gt;
&lt;li&gt;结束条件&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="python数据结构" scheme="http://example.com/tags/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>说走就走的滑雪</title>
    <link href="http://example.com/2021/12/05/%E8%AF%B4%E8%B5%B0%E5%B0%B1%E8%B5%B0%E7%9A%84%E6%BB%91%E9%9B%AA/"/>
    <id>http://example.com/2021/12/05/%E8%AF%B4%E8%B5%B0%E5%B0%B1%E8%B5%B0%E7%9A%84%E6%BB%91%E9%9B%AA/</id>
    <published>2021-12-05T14:13:45.000Z</published>
    <updated>2021-12-05T14:42:15.509Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>突然想去滑雪了，于是…</p><p>我摔得好惨，就连魔术滑道都摔了2次，太丢人了😂</p><p>不过好在最终学会了双板，嗯应该学会了吧。第一次滑雪直接练习的中级赛道，下次有机会我想滑单板。</p><p>滑雪我有点上瘾了</p><span id="more"></span><p><img src="./3.jpeg"></p></br><p><img src="./4.jpeg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;突然想去滑雪了，于是…&lt;/p&gt;
&lt;p&gt;我摔得好惨，就连魔术滑道都摔了2次，太丢人了😂&lt;/p&gt;
&lt;p&gt;不过好在最终学会了双板，嗯应该学会了吧。第一次滑雪直接练习的中级赛道，下次有机会我想滑单板。&lt;/p&gt;
&lt;p&gt;滑雪我有点上瘾了&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="2021" scheme="http://example.com/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>Linux tcpdump命令</title>
    <link href="http://example.com/2021/12/01/Linux-tcpdump%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/12/01/Linux-tcpdump%E5%91%BD%E4%BB%A4/</id>
    <published>2021-12-01T14:47:48.000Z</published>
    <updated>2021-12-01T15:24:13.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>tcpdump是一个强大的网络抓包Sniffer类工具，通常用在Linux系统中，Windows操作系统中也会使用，可以看作是WireShark的命令行版本。</p><p>tcdpump命令最初设计用于观察TCP/IP性能问题，它是一个用于截取网络分组，并输出分组内容的工具。tcpdump可以将网络中传送的数据包的报文头完全截获下来提供分析，它支持针对网络层、协议、主机、网络或端口的过滤，并提供and，or，not等逻辑语句来帮助用户去掉无用的信息。</p><span id="more"></span><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [-adeflnNOpqStvx][-c&lt;数据包数目&gt;][-dd][-ddd][-F&lt;表达文件&gt;][-i&lt;网络界面&gt;][-r&lt;数据包文件&gt;][-s&lt;数据包大小&gt;][-tt][-T&lt;数据包类型&gt;][-vv][-w&lt;数据包文件&gt;][输出数据栏位]</span><br></pre></td></tr></table></figure><!--more--><h4 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h4><p><code>tcpdump -i wlan0 -s 0 -w a.cap</code> //监听wlan0网卡上的全部流量，-s代表抓取包的大小，默认为抓取64,设置为0， 表示包有多大，抓多大。-w，表示抓取下来保存为，a.cap</p><p><code>tcpdump -r a.cpa</code></p><p><code>tcpdump -A -r a.cap</code> //以Ascall显示包文件</p><p><code>tcpdump -x -r a.cap</code> //以十六进制显示包文件</p><p><code>tcpdump -i eth0 tcp port 22</code> //监听tcp协议的，22端口</p><p>tcpdump—筛选</p><p><code>tcpdump -n -r http.cap | awk &#39;&#123;print $3&#125;&#39; |sort -u</code> // -n 表示只以ip地址的形式显示出来，不显示域名。awk 参数表示只显示第三列信息; sort表示去掉重复的</p><p><code>tcpdump -n src host 145.254.160.237 -r http.cap //source</code></p><p><code>tcpdump -n dst host 145.254.160.237 -r http.cap //destination</code></p><p><code>tcpdump -n udp port 53 -r http.cap</code> //使用udp 53端口就可以把所有的域名查询包显示出来</p><p><code>tcpdump -nX port 80 -r http.cap</code> //十六进制</p><p><code>tcpdump -A -n &#39;tcp[13] = 24&#39; -r http.cap</code> //筛选tcp包里面的ack和psh包</p><p>Linux tcpdump命令用于倾倒网络传输数据。</p><p>执行tcpdump指令可列出经过指定网络界面的数据包文件头，在Linux操作系统中，你必须是系统管理员。</p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>-a 尝试将网络和广播地址转换成名称。</li><li>-c&lt;数据包数目&gt; 收到指定的数据包数目后，就停止进行倾倒操作。</li><li>-d 把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。</li><li>-dd 把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出。</li><li>-ddd 把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。</li><li>-e 在每列倾倒资料上显示连接层级的文件头。</li><li>-f 用数字显示网际网络地址。</li><li>-F&lt;表达文件&gt; 指定内含表达方式的文件。</li><li>-i&lt;网络界面&gt; 使用指定的网络截面送出数据包。</li><li>-l 使用标准输出列的缓冲区。</li><li>-n 不把主机的网络地址转换成名字。</li><li>-N 不列出域名。</li><li>-O 不将数据包编码最佳化。</li><li>-p 不让网络界面进入混杂模式。</li><li>-q 快速输出，仅列出少数的传输协议信息。</li><li>-r&lt;数据包文件&gt; 从指定的文件读取数据包数据。</li><li>-s&lt;数据包大小&gt; 设置每个数据包的大小。</li><li>-S 用绝对而非相对数值列出TCP关联数。</li><li>-t 在每列倾倒资料上不显示时间戳记。</li><li>-tt 在每列倾倒资料上显示未经格式化的时间戳记。</li><li>-T&lt;数据包类型&gt; 强制将表达方式所指定的数据包转译成设置的数据包类型。</li><li>-v 详细显示指令执行过程。</li><li>-vv 更详细显示指令执行过程。</li><li>-x 用十六进制字码列出数据包资料。</li><li>-w&lt;数据包文件&gt; 把数据包数据写入指定的文件。</li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><p>抓取所有的包</p><p><code>tcpdump -i any -n -w xxx.cap</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;tcpdump是一个强大的网络抓包Sniffer类工具，通常用在Linux系统中，Windows操作系统中也会使用，可以看作是WireShark的命令行版本。&lt;/p&gt;
&lt;p&gt;tcdpump命令最初设计用于观察TCP/IP性能问题，它是一个用于截取网络分组，并输出分组内容的工具。tcpdump可以将网络中传送的数据包的报文头完全截获下来提供分析，它支持针对网络层、协议、主机、网络或端口的过滤，并提供and，or，not等逻辑语句来帮助用户去掉无用的信息。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>面纱</title>
    <link href="http://example.com/2021/11/30/%E9%9D%A2%E7%BA%B1/"/>
    <id>http://example.com/2021/11/30/%E9%9D%A2%E7%BA%B1/</id>
    <published>2021-11-30T13:37:13.000Z</published>
    <updated>2021-12-04T10:56:06.684Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-vboWEvlV" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="16139396" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div></br><blockquote><p>50岁时毛姆写下这个近乎完美的爱情故事，因为每个人都在故事中找到了自己。这本小说讲述了爱情中所有的不美好：背叛、猜忌、报复，还有我们终将面对的离别与自我救赎。毛姆以他冷静得近乎刻薄的方式，将一个女人的堕落与觉醒刻画得淋漓尽致。凯蒂怎么也琢磨不透，文夫到底有没有发现她出轨的秘密偷情时门把手的转动、晚餐时意有所指的话语，还有突然要带她前往霍乱之地的决定，这些都让凯蒂的神经越绷越紧。终于，忍无可忍的她打算摊牌，离婚后投奔心爱的情人。然而面纱揭开，爱情的真相与人生的意义将她的天真击得粉碎。毛姆以他冷静得近乎刻薄的方式，将一个女人的堕落与觉醒刻画得淋漓尽致–在两个人的世界里，她只能选择爱他或者失去他，以填补心灵的空虛；但当她身处更为广袤的世界，目睹了生活的残酷和人性的光辉之后，才真正获<br>得了心灵的宁静和对自我的救赎。</p></blockquote><span id="more"></span><blockquote><p>你用面纱遮蔽他人的窥探，自己也难以一睹世界之真实。</p></blockquote><p>这本小说真是一部让人揪心的作品</p><p>沃尔特爱而不得，凯蒂的个人成长，查理的渣男行为都被描写的淋漓尽致</p><blockquote><p>“我对你不抱什么幻想，”他说，“我知道你愚蠢、轻浮、没有头脑，但是我爱你。我知道你的目标和理想既庸俗又普通，但是我爱你。我知道你是二流货色，但是我爱你。想一想真是好笑，我竭力去喜欢那些讨你喜欢的东西，忍受折磨也要对你隐瞒起自己，实际上我并不无知粗俗、不爱散播丑闻也不愚蠢。我知道你何等害怕智慧，便尽我所能让你觉得我是个大傻瓜，跟你认识的其他人一样。我知道你嫁给我只图一时利益，我是那样爱你，我不在乎。大多数人，就我所知，当他们爱一个人，却没有得到爱的回报时就会觉得委屈不平，甚至愈发愤怒和痛苦。我不是那样，我从来没有指望你爱我，我看不出任何理由让你爱我，我也从来没想过自己会被人爱。我很感激能被允许爱你，当我时常想起你高兴跟我在一起，或者当我发现你眼中闪烁着愉快的爱意时，我就会欣喜若狂。我尽量不让我的爱来烦扰你，我知道那会让我承受不起，所以我一直察言观色，留意我的爱让你厌烦的最初迹象。大部分丈夫认为那是一种权力，我却准备当成恩惠来接受。”</p></blockquote><p>个人认为沃尔特是一个很拧巴的人，当他知道凯蒂出轨后，他就带上了一副面具。他深爱着凯蒂，却不愿意过多的表达。毕竟对方是出轨者，他有自己的骄傲，但终究是败给了爱情。</p><blockquote><p>假如汤森太太向我保证她会跟她丈夫离婚，假如他给我一份书面承诺，保证在两份判决生效的一个星期内娶你，我就答应你。”</p></blockquote><blockquote><p>“你特别瞧不起我吧，沃尔特？”<br>“不。”他犹豫了一下，声音十分奇怪，“我瞧不起我自己。”</p><p>“因为我爱你。”</p></blockquote><p>他无疑用他自己的方式深爱着凯蒂，却让凯蒂觉得自己是一个客人，而非是家庭的一员。（找不到那一段话了）</p><p>我个人感觉他的爱太卑微、太深沉了，打动了千万读者读者，却打动不了凯蒂。其实，对于这一点没有人怪凯蒂，因为换做任何一个人可能都无法接受这样的爱吧。</p><p>一开始沃尔特是想与凯蒂一起死的，因为他们去瘟疫肆虐的湄潭府无疑是送死。这点凯蒂问过他，去过之后呢，他没有想过。在书的尾声，他也承认了自己当时确实想让她死在那里。</p><p>哎，何必呢。</p><p>凯蒂在修女院中获得了新生与成长。当他们渐渐拨开层层云雾，慢慢和解，凯蒂却怀了身孕。</p><blockquote><p>“我要生孩子了。”她说。</p><p>当她说出一句本以为会引发惊叹的话，他却习惯以沉默相对，这在她已见怪不怪，但从未像现在这样令她难以忍受。他什么也没说，也没做任何手势，脸上和那双黑眼睛里的神色没有任何变化，以表示他听见了。她突然有种想哭的冲动。如果一个男人爱他的妻子，他的妻子也爱他，在这样的时刻，他们本该受一种强烈的情感驱使着紧紧抱在一起。沉默令人不堪忍受，她耐不住了。</p><p>“我不知道为什么以前我从未想到这一点。我太愚蠢了，不过……由于种种原因……”</p><p>“你有多长时间……你估计什么时候分娩？”</p><p>这话似乎花了好大力气才从他嘴里说出来，她觉得他喉咙发干，就跟她自己一样。可恨的是她说起话来嘴唇一直打颤，如果他不是石头做的，这也该激发他的恻隐之心了吧。</p><p>“我估计已经有两三个月了。”</p><p>“我是那父亲吗？”</p><p>她倒吸一口冷气，他的声音里有一丝颤抖。他一贯冷静、自我克制，以至于微乎其微的情感表示都会让她震惊，这简直太可怕了。她不知为什么想到了在香港见过的一种仪器，上面有一根指针轻轻振动，人们告诉她那代表上千英里外发生了一场地震，想必上千人会丧失生命。她看着他，他面如死灰，这种苍白她以前见过一到两次。他低着头，稍稍看着一边。</p><p>“是吗？”</p></blockquote><p>算了，一切都是无言。</p><p>刚开始挺为沃尔特感到难过的，但后来慢慢发现他也是一个卑微的普通人，小说最后成长了的只有凯蒂一个人。他能原谅凯蒂的出轨，却无法视肚子里的孩子不见，最后我想他是自杀吧。</p><blockquote><p>别瞎忙了。我经过了一段艰难的路途，但现在已经全好了。”<br>凯蒂又等了一会儿，但只有沉默。他全然不动的样子撕扯着她凄苦的心。看见他竟那样毫无动静地躺着，太过让人害怕——他似乎已经准备好寂然进入坟墓。</p></blockquote><p>亲眼看见深爱之人的背叛，用永无休止的忙碌去麻痹自己破碎的心，把死亡看成最后解脱的沃尔特你太傻了。</p><blockquote><p>人生何其短暂，世界本来就充满了痛苦，人们却还是要折磨自己，这岂不是太可怜了吗？</p></blockquote><p>你是那个痴情的凯蒂，成为了口中的那只狗，而凯蒂则变成了善人。</p><blockquote><p>过去已经完结，逝者已然安息。这样是不是太过无情？她满心希望自己已经学会同情和博爱，即使不知道什么样的未来在等待着她，也感到内心有一股力量，无论将要发生什么，她都能带着轻松愉悦的心情去接受。接着，突然之间，全然说不清是何因由，那段旅行的回忆从她无意识的脑海深处浮现出来：她跟着可怜的沃尔特，两人一道前往那座饱受瘟疫摧残、让他丢了性命的城市——一天早上，天还没亮他们便坐上轿子出发。破晓之时，与其说她看到，不如说是凭直觉预见了那样一幅令人惊叹的美妙景致，一时缓和了她心里的痛苦，让尘世间的所有磨难都显得无关重要。太阳升起来，驱散了一片雾霭，她看见他们循着的那条小径蜿蜒向前，直到目力不及之处，穿插于稻田之间，横跨过一条小河，越过高低起伏的大地——也许她的过失，她做下的蠢事，还有她所遭受的不幸，并非一概徒劳无益，只要现在她能够遵循眼前这条让她依稀可辨的路。那不是亲切古怪的老沃丁顿所说的无所通达的道路，而是修道院那些可爱的修女谦卑地遵循的路——那是一条通往内心安宁的路。</p></blockquote><p>所有的伤、所有的恨都该慢慢学着与自己和解。现在失恋的男女也是一样啊，如果在所爱的人背叛自己后，能有勇气断掉一切，学着与自己和解是否能像凯蒂一样获得新生。</p></br><p><strong>与世界和解，与往事和解。</strong></p><p><strong>原谅该原谅的，忘记该忘记的。</strong></p><p><strong>记住该记住的，回忆该回忆的。</strong></p><p><strong>未来很长，当有勇气面对，当与自己和解。</strong></p></br><p>让我想到了两首歌：《一直很安静》和《路过人间》</p>    <div id="aplayer-oINYsGDf" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="505997881" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div></br>    <div id="aplayer-rbyAuHCR" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1495052210" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div></br><p><img src="1.jpg"></p><center><small>11.27号在国家图书馆无意间发现了这本书</small></center>]]></content>
    
    
    <summary type="html">&lt;div id=&quot;aplayer-vboWEvlV&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;16139396&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#ad7a86&quot;
    &gt;&lt;/div&gt;

&lt;/br&gt;

&lt;blockquote&gt;
&lt;p&gt;50岁时毛姆写下这个近乎完美的爱情故事，因为每个人都在故事中找到了自己。这本小说讲述了爱情中所有的不美好：背叛、猜忌、报复，还有我们终将面对的离别与自我救赎。毛姆以他冷静得近乎刻薄的方式，将一个女人的堕落与觉醒刻画得淋漓尽致。凯蒂怎么也琢磨不透，文夫到底有没有发现她出轨的秘密偷情时门把手的转动、晚餐时意有所指的话语，还有突然要带她前往霍乱之地的决定，这些都让凯蒂的神经越绷越紧。终于，忍无可忍的她打算摊牌，离婚后投奔心爱的情人。然而面纱揭开，爱情的真相与人生的意义将她的天真击得粉碎。毛姆以他冷静得近乎刻薄的方式，将一个女人的堕落与觉醒刻画得淋漓尽致–在两个人的世界里，她只能选择爱他或者失去他，以填补心灵的空虛；但当她身处更为广袤的世界，目睹了生活的残酷和人性的光辉之后，才真正获&lt;br&gt;得了心灵的宁静和对自我的救赎。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="书评" scheme="http://example.com/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
    <category term="2021" scheme="http://example.com/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 两数之和II-输入有序数组</title>
    <link href="http://example.com/2021/11/29/leetcode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2021/11/29/leetcode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2021-11-29T12:48:13.000Z</published>
    <updated>2021-11-29T12:49:59.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照 <strong>非递减顺序排列</strong> 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p><p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值<em>。</em><code>numbers</code> 的下标 <strong>从 1 开始计数</strong> ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code> 。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">numbers</span> = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], <span class="attr">target</span> = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：<span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 <span class="attr">index1</span> = <span class="number">1</span>, <span class="attr">index2</span> = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = <span class="comment">[2,3,4]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[1,3]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = <span class="comment">[-1,0]</span>, target = -1</span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= numbers.length &lt;= 3 * 104</code></li><li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li><li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li><li><code>-1000 &lt;= target &lt;= 1000</code></li><li><strong>仅存在一个有效答案</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><strong>思考</strong></p><p>写两个for循环，然后将每个列表的两个值一一相加，直到得出目标值。</p><p>通过enumerate()得出下标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num = <span class="built_in">len</span>(numbers)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,num):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,num):</span><br><span class="line">                <span class="keyword">if</span> numbers[i]+numbers[k] == target:</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>,k+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>但这样并没有通过，超出了时间限制，还记得二分查找吗？</p><p><strong>非递归二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params"><span class="built_in">list</span>,item</span>):</span></span><br><span class="line">    <span class="comment"># 列表的头和尾，代表着数组范围的最小和最大</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(<span class="built_in">list</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当找到item的时候，low是小于high，也有可能相等</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 取数组的中间值</span></span><br><span class="line">        guess = <span class="built_in">list</span>[mid]</span><br><span class="line">        <span class="comment"># 如果中间值等于索引值，那么就返回中间值的下标</span></span><br><span class="line">        <span class="keyword">if</span> guess == item:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果中间值&gt;索引值，因为不包含中间值，所以最大范围high=中间值的下标往左移1位</span></span><br><span class="line">        <span class="keyword">if</span> guess &gt; item:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果中间值&lt;索引值，因为不包含中间值，所以最小范围low=中间值的下标往右移1位</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(binary_search(my_list,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改进后             </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(numbers)-<span class="number">1</span>      </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> numbers[left] + numbers[right] == target:                </span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> numbers[left] + numbers[right] &lt; target:</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = right - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>附递归二分查找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params"><span class="built_in">list</span>,data</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(<span class="built_in">list</span>)</span><br><span class="line">    mid = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">list</span>[mid] &gt; data:</span><br><span class="line">        <span class="keyword">return</span> binary_search(<span class="built_in">list</span>[<span class="number">0</span>:mid],data)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">list</span>[mid] &lt; data:</span><br><span class="line">        <span class="keyword">return</span> binary_search(<span class="built_in">list</span>[mid+<span class="number">1</span>:],data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure><p><strong>java双指针</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;167-两数之和-II-输入有序数组&quot;&gt;&lt;a href=&quot;#167-两数之和-II-输入有序数组&quot; class=&quot;headerlink&quot; title=&quot;167. 两数之和 II - 输入有序数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/&quot;&gt;167. 两数之和 II - 输入有序数组&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定一个已按照 &lt;strong&gt;非递减顺序排列&lt;/strong&gt; 的整数数组 &lt;code&gt;numbers&lt;/code&gt; ，请你从数组中找出两个数满足相加之和等于目标数 &lt;code&gt;target&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;函数应该以长度为 &lt;code&gt;2&lt;/code&gt; 的整数数组的形式返回这两个数的下标值&lt;em&gt;。&lt;/em&gt;&lt;code&gt;numbers&lt;/code&gt; 的下标 &lt;strong&gt;从 1 开始计数&lt;/strong&gt; ，所以答案数组应当满足 &lt;code&gt;1 &amp;lt;= answer[0] &amp;lt; answer[1] &amp;lt;= numbers.length&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;你可以假设每个输入 &lt;strong&gt;只对应唯一的答案&lt;/strong&gt; ，而且你 &lt;strong&gt;不可以&lt;/strong&gt; 重复使用相同的元素。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>蛤蟆先生去看心理医生</title>
    <link href="http://example.com/2021/11/28/%E8%9B%A4%E8%9F%86%E5%85%88%E7%94%9F%E5%8E%BB%E7%9C%8B%E5%BF%83%E7%90%86%E5%8C%BB%E7%94%9F/"/>
    <id>http://example.com/2021/11/28/%E8%9B%A4%E8%9F%86%E5%85%88%E7%94%9F%E5%8E%BB%E7%9C%8B%E5%BF%83%E7%90%86%E5%8C%BB%E7%94%9F/</id>
    <published>2021-11-28T14:27:23.000Z</published>
    <updated>2021-11-29T15:10:38.237Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>感谢妞妞给我推荐这本心理书，与自己和解。让我了解了很多心理学的知识，这个周六在统一写书评吧。</p><p>没想到在图书馆随便找的一本书——《面纱》太好看了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="书评" scheme="http://example.com/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
    <category term="2021" scheme="http://example.com/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>python zip()函数</title>
    <link href="http://example.com/2021/11/28/python-zip-%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/11/28/python-zip-%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-28T14:21:05.000Z</published>
    <updated>2021-11-28T14:22:12.811Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ol><li>zip含有两种，其中一种是zip()——压缩，另外一种是zip(* )——解压</li><li>zip 函数在 Python 2 和 Python 3 中是有所不同的：<ul><li>在 Python 3.x 中为了减少内存，zip() 返回的是一个对象object。如果需展示列表，需手动 list() 转换。</li><li>在Python2.x中返回的是一个列表list。</li></ul></li></ol><span id="more"></span><p><strong>语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">zip</span>([iterable, ...])</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><p>iterable：一个序列或其他的可迭代对象</p><p><strong>功能</strong></p><p>将可迭代的对象作为参数，将对象中对应的元素打包成一个个<strong>元组</strong>，然后返回由这些元组组成的<strong>列表</strong>。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。（可利用 * 号操作符，可以将元组解压为列表。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>=([<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># zip压缩</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1=<span class="built_in">zip</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># zip解压</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2=<span class="built_in">zip</span>(*<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出压缩后的a1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(a1)</span><br><span class="line">[([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],), ([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>],)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出解压后的a2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(a2)</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;2&#x27;</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x7f273dc97200</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a1)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">zip</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>在LeetCode上有一道题（14.Longest Common Prefix），使用set()与zip()函数是最快的解决方法，时间复杂度也是最小的。<a href="https://leetcode.com/problems/longest-common-prefix/">https://leetcode.com/problems/longest-common-prefix/</a> 。下面贴出解答方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longsetCommonPrefix</span>(<span class="params">strs</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化一个字符串s，用来接受无门要求的最长的公共前缀</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 先判断strs是不是一个空字符串，如果是，则返回 ”“</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># print(list(zip(strs)))</span></span><br><span class="line">    <span class="comment"># print(list(zip(*strs)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 利用zip(*)函数对字符串strs进行解压，得到一个列表，再遍历该列表</span></span><br><span class="line">    <span class="comment"># 该列表是由字符串strs每个元素打包成一个一个元组，然后再将这些元组解压（拆分）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">zip</span>(*strs):</span><br><span class="line">    <span class="comment"># 3. 对zip解压得到的列表中的每个元素用set()创建一个无序不重复的元素集合</span></span><br><span class="line">    <span class="comment"># 判断每个集合的长度是否为1，如果为1，则说明是公共前缀，并入字符串s中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 利用集合创建一个无序不重复的元素集</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(each)) == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># print(set(each))</span></span><br><span class="line">            s += each[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>调用longestCommonPrefix()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最大公共前缀为：%s&quot;</span> %longsetCommonPrefix(<span class="built_in">str</span>))</span><br></pre></td></tr></table></figure><p>下面是Python的运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">&#x27;flower&#x27;</span>,), (<span class="string">&#x27;flow&#x27;</span>,), (<span class="string">&#x27;flight&#x27;</span>,)]</span><br><span class="line">[(<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;f&#x27;</span>), (<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>), (<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;i&#x27;</span>), (<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)]</span><br><span class="line">&#123;<span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line">最大公共前缀为：fl</span><br></pre></td></tr></table></figure><blockquote><p>转载自：<a href="https://blog.csdn.net/weixin_44412496/article/details/97925652">https://blog.csdn.net/weixin_44412496/article/details/97925652</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;zip含有两种，其中一种是zip()——压缩，另外一种是zip(* )——解压&lt;/li&gt;
&lt;li&gt;zip 函数在 Python 2 和 Python 3 中是有所不同的：&lt;ul&gt;
&lt;li&gt;在 Python 3.x 中为了减少内存，zip() 返回的是一个对象object。如果需展示列表，需手动 list() 转换。&lt;/li&gt;
&lt;li&gt;在Python2.x中返回的是一个列表list。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python中sys.argv[]的用法简明解释</title>
    <link href="http://example.com/2021/11/28/python%E4%B8%ADsys-argv-%E7%9A%84%E7%94%A8%E6%B3%95%E7%AE%80%E6%98%8E%E8%A7%A3%E9%87%8A/"/>
    <id>http://example.com/2021/11/28/python%E4%B8%ADsys-argv-%E7%9A%84%E7%94%A8%E6%B3%95%E7%AE%80%E6%98%8E%E8%A7%A3%E9%87%8A/</id>
    <published>2021-11-28T08:49:14.000Z</published>
    <updated>2021-11-28T08:50:42.089Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Python中 sys.argv[]的用法简明解释</p><p>   因为是看书自学的python，开始后不久就遇到了这个引入的模块函数，且一直在IDLE上编辑了后运行，试图从结果发现它的用途，然而结果一直都是没结果，也在网上查了许多，但发现这个问题的比较详细的解释只有一个版本，大部分都是转载和复制的。给的都是简明python教程上那个一长串代码的例子，说看了就明白了，可我看得晕头转向的还是没真正明白，只知道“sys.argv[0]表示代码本身文件路径”这点，其实还是不明其意。后来经过大量努力，多方求教才真正明悟了，谨以记录和分享，希望能从另一个角度给同在求索过程中的同学一点启发。</p><span id="more"></span><p>　　sys.argv[]说白了就是一个从程序外部获取参数的桥梁，这个“外部”很关键，所以那些试图从代码来说明它作用的解释一直没看明白。因为我们从外部取得的参数可以是多个，所以获得的是一个列表（list)，也就是说sys.argv其实可以看作是一个列表，所以才能用[]提取其中的元素。其第一个元素是程序本身，随后才依次是外部给予的参数。</p><p>下面我们通过一个极简单的test.py程序的运行结果来说明它的用法。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>#test.py</span><br><span class="line"><span class="symbol">2 </span></span><br><span class="line"><span class="symbol">3 </span>import sys</span><br><span class="line"><span class="symbol">4 </span>a=sys.argv[<span class="number">0</span>]</span><br><span class="line"><span class="symbol">5 </span><span class="keyword">print</span>(a)</span><br></pre></td></tr></table></figure><p>将test.py保存在c盘的根目录下。</p><p>在程序中找到 ‘运行’-&gt;点击-&gt;输入”cmd”-&gt;回车键  进入控制台命令窗口（如下图），先输入cd c:\  (作用是将命令路径改到c盘根目录)，然后输入test.py运行我们刚刚写的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">william@DESKTOP:~/DYJ/Python$ python3 test.py</span><br><span class="line">test.py</span><br></pre></td></tr></table></figure><p>得到的结果是C:\test.py，这就是0指代码（即此.py程序）本身的意思。</p><p>然后我们将代码中0改为1 :</p><p>a=sys.argv[1]</p><p>保存后，再从控制台窗口运行，这次我们加上一个参数，输入：test.py what</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">william@DESKTOP-MDEKEAT:~/DYJ/Python$ python3 test.py what</span><br><span class="line">what</span><br></pre></td></tr></table></figure><p> 得到的结果就是我们输入的参数what，看到这里你是不是开始明白了呢。</p><p>那我们再把代码修改一下：</p><p>a=sys.argv[2：]</p><p>保存后，再从控制台窗台运行程序，这次多加几个参数，以空格隔开:</p><p>test.py a b c d e f</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">william@DESKTOP-MDEKEAT:~/DYJ/Python$ python3 test.py a b c d e f</span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]</span><br></pre></td></tr></table></figure><p>得到的结果为[‘b’, ’c’, ’d’, ’e’, ’f’]</p><p>应该大彻大悟了吧。Sys.argv[ ]其实就是一个列表，里边的项为用户输入的参数，关键就是要明白这参数是从程序外部输入的，而非代码本身的什么地方，要想看到它的效果就应该将程序保存了，从外部来运行程序并给出参数。</p><p><a href="http://www.cnblogs.com/aland-1415/p/7128121.html">Python3 从入门到开车</a></p><blockquote><p><a href="https://www.cnblogs.com/aland-1415/p/6613449.html">https://www.cnblogs.com/aland-1415/p/6613449.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python中 sys.argv[]的用法简明解释&lt;/p&gt;
&lt;p&gt;   因为是看书自学的python，开始后不久就遇到了这个引入的模块函数，且一直在IDLE上编辑了后运行，试图从结果发现它的用途，然而结果一直都是没结果，也在网上查了许多，但发现这个问题的比较详细的解释只有一个版本，大部分都是转载和复制的。给的都是简明python教程上那个一长串代码的例子，说看了就明白了，可我看得晕头转向的还是没真正明白，只知道“sys.argv[0]表示代码本身文件路径”这点，其实还是不明其意。后来经过大量努力，多方求教才真正明悟了，谨以记录和分享，希望能从另一个角度给同在求索过程中的同学一点启发。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>爱的艺术</title>
    <link href="http://example.com/2021/11/27/%E7%88%B1%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>http://example.com/2021/11/27/%E7%88%B1%E7%9A%84%E8%89%BA%E6%9C%AF/</id>
    <published>2021-11-27T12:41:10.000Z</published>
    <updated>2021-11-28T14:26:21.636Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这本书值得反复阅读，第一遍阅读很多地方都不是很明白，加上一些事情耽搁，没有写笔记。导致现在忘得差不多了，如果有时间我会再读一遍，然后补上书评。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="书评" scheme="http://example.com/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
    <category term="2021" scheme="http://example.com/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>python __name__==&#39;__main__&#39;作用详解</title>
    <link href="http://example.com/2021/11/27/python-name-main-%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/11/27/python-name-main-%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-11-27T09:43:15.000Z</published>
    <updated>2021-11-27T09:53:34.587Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在阅读别人写的自定义模块时，经常会看到有如下这行判断语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br></pre></td></tr></table></figure><p>这行代码的作用是什么呢？本节就详解讲解以下它的作用。</p><span id="more"></span><p>一般情况下，当我们写完自定义的模块之后，都会写一个测试代码，检验一些模块中各个功能是否能够成功运行。例如，创建一个 candf.py 文件，并编写如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">摄氏度和华氏度的相互转换模块</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c2f</span>(<span class="params">cel</span>):</span></span><br><span class="line">    fah = cel * <span class="number">1.8</span> + <span class="number">32</span></span><br><span class="line">    <span class="keyword">return</span> fah</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2c</span>(<span class="params">fah</span>):</span></span><br><span class="line">    cel = (fah - <span class="number">32</span>) / <span class="number">1.8</span></span><br><span class="line">    <span class="keyword">return</span> cel</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试数据：0 摄氏度 = %.2f 华氏度&quot;</span> % c2f(<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试数据：0 华氏度 = %.2f 摄氏度&quot;</span> % f2c(<span class="number">0</span>))</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>单独运行此模块文件，可以看到如下运行结果：</p><p>测试数据：0 摄氏度 = 32.00 华氏度<br>测试数据：0 华氏度 = -17.78 摄氏度</p><p>在 candf.py 模块文件的基础上，在同目录下再创建一个 demo.py 文件，并编写如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> candf</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;32 摄氏度 = %.2f 华氏度&quot;</span> % candf.c2f(<span class="number">32</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;99 华氏度 = %.2f 摄氏度&quot;</span> % candf.f2c(<span class="number">99</span>))</span><br></pre></td></tr></table></figure><p>运行 demo.py 文件，其运行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试数据：0 摄氏度 = 32.00 华氏度</span><br><span class="line">测试数据：0 华氏度 = -17.78 摄氏度</span><br><span class="line">32 摄氏度 = 89.60 华氏度</span><br><span class="line">99 华氏度 = 37.22 摄氏度</span><br></pre></td></tr></table></figure><p>可以看到，<a href="http://c.biancheng.net/python/">Python</a>解释器将模块（candf.py）中的测试代码也一块儿运行了，这并不是我们想要的结果。想要避免这种情况的关键在于，要让 Python 解释器知道，当前要运行的程度代码，是模块文件本身，还是导入模块的其它程序。</p><p>为了实现这一点，就需要使用 Python 内置的系统变量 __name__，它用于标识所在模块的模块名。例如，在 demo.py 程序文件中，添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(__name__)</span><br><span class="line"><span class="built_in">print</span>(candf.__name__)</span><br><span class="line">其运行结果为：</span><br><span class="line">__main__</span><br><span class="line">candf</span><br></pre></td></tr></table></figure><p>可以看到，当前运行的程序，其 <strong>name</strong> 的值为 __main__，而导入到当前程序中的模块，其 <strong>name</strong> 值为自己的模块名。</p><p>因此，<code>if __name__ == &#39;__main__&#39;:</code> 的作用是确保只有单独运行该模块时，此表达式才成立，才可以进入此判断语法，执行其中的测试代码；反之，如果只是作为模块导入到其他程序文件中，则此表达式将不成立，运行其它程序时，也就不会执行该判断语句中的测试代码。</p><blockquote><p>转载自：<a href="http://c.biancheng.net/view/4643.html">http://c.biancheng.net/view/4643.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在阅读别人写的自定义模块时，经常会看到有如下这行判断语句：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&amp;#x27;__main__&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这行代码的作用是什么呢？本节就详解讲解以下它的作用。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>江南逢李龟年</title>
    <link href="http://example.com/2021/11/25/%E6%B1%9F%E5%8D%97%E9%80%A2%E6%9D%8E%E9%BE%9F%E5%B9%B4/"/>
    <id>http://example.com/2021/11/25/%E6%B1%9F%E5%8D%97%E9%80%A2%E6%9D%8E%E9%BE%9F%E5%B9%B4/</id>
    <published>2021-11-25T14:29:44.000Z</published>
    <updated>2021-11-25T15:19:03.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-gbcRuMcH" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="816965" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div></br><center>岐王宅里寻常见，</br></br>崔九堂前几度闻。</br></br>正是江南好风景，</br></br>落花时节又逢君。</br></center><span id="more"></span><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://www.bilibili.com/video/BV1Mh41147ty?spm_id_from=333.999.0.0"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;div id=&quot;aplayer-gbcRuMcH&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;816965&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#ad7a86&quot;
    &gt;&lt;/div&gt;

&lt;/br&gt;



&lt;center&gt;
岐王宅里寻常见，&lt;/br&gt;&lt;/br&gt;
崔九堂前几度闻。&lt;/br&gt;&lt;/br&gt;
正是江南好风景，&lt;/br&gt;&lt;/br&gt;
落花时节又逢君。&lt;/br&gt;
&lt;/center&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="诗词歌赋" scheme="http://example.com/tags/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>python enumerate()说明</title>
    <link href="http://example.com/2021/11/25/python-enumerate-%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2021/11/25/python-enumerate-%E8%AF%B4%E6%98%8E/</id>
    <published>2021-11-25T13:55:15.000Z</published>
    <updated>2021-11-25T14:07:18.988Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="enumerate-说明"><a href="#enumerate-说明" class="headerlink" title="enumerate()说明"></a>enumerate()说明</h2><ul><li><p>enumerate()是python的内置函数</p></li><li><p>enumerate在字典上是枚举、列举的意思</p></li><li><p>对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值</p></li></ul><span id="more"></span><ul><li><p>enumerate多用于在for循环中得到计数</p></li><li><p>例如对于一个seq，得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>,seq[<span class="number">0</span>]),(<span class="number">1</span>,seq[<span class="number">1</span>]),(<span class="number">2</span>,seq[<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li><li><p>enumerate()返回一个enumerate对象，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">enumerate</span>(seq)</span><br><span class="line">&lt;<span class="built_in">enumerate</span> <span class="built_in">object</span> at <span class="number">0x7f74995b8140</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="enumerate-使用"><a href="#enumerate-使用" class="headerlink" title="enumerate()使用"></a>enumerate()使用</h2><ul><li><p>如果对一个列表，既要遍历索引又要遍历元素时，首先可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="string">&quot;这&quot;</span>,<span class="string">&quot;是&quot;</span>,<span class="string">&quot;一个&quot;</span>,<span class="string">&quot;测试&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list1)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i,list1[i])</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> 这</span><br><span class="line"><span class="number">1</span> 是</span><br><span class="line"><span class="number">2</span> 一个</span><br><span class="line"><span class="number">3</span> 测试</span><br></pre></td></tr></table></figure></li><li><p>上述方法有些累赘，利用enumerate()会更加直接和优美：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="string">&quot;这&quot;</span>,<span class="string">&quot;是&quot;</span>,<span class="string">&quot;一个&quot;</span>,<span class="string">&quot;测试&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(index,item)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> 这</span><br><span class="line"><span class="number">1</span> 是</span><br><span class="line"><span class="number">2</span> 一个</span><br><span class="line"><span class="number">3</span> 测试</span><br></pre></td></tr></table></figure></li><li><p>enumerate还可以接收第二个参数，用于指定索引起始值，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="string">&quot;这&quot;</span>,<span class="string">&quot;是&quot;</span>,<span class="string">&quot;一个&quot;</span>,<span class="string">&quot;测试&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1,<span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(index,item)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> 这</span><br><span class="line"><span class="number">2</span> 是</span><br><span class="line"><span class="number">3</span> 一个</span><br><span class="line"><span class="number">4</span> 测试</span><br></pre></td></tr></table></figure></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果要统计文件的行数，可以这样写：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="built_in">len</span>(<span class="built_in">open</span>(filepath,<span class="string">&#x27;r&#x27;</span>).readlines())</span><br></pre></td></tr></table></figure><p>这种方法简单，但是可能比较慢，当文件比较大时甚至不能工作。</p><p>可以利用enumerate()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> index,line <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">open</span>(filepath,<span class="string">&#x27;r&#x27;</span>)):</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>转载自：<a href="https://www.cnblogs.com/oddcat/articles/9630404.html">https://www.cnblogs.com/oddcat/articles/9630404.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;enumerate-说明&quot;&gt;&lt;a href=&quot;#enumerate-说明&quot; class=&quot;headerlink&quot; title=&quot;enumerate()说明&quot;&gt;&lt;/a&gt;enumerate()说明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;enumerate()是python的内置函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;enumerate在字典上是枚举、列举的意思&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 最长公共前缀</title>
    <link href="http://example.com/2021/11/24/leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://example.com/2021/11/24/leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</id>
    <published>2021-11-24T15:00:38.000Z</published>
    <updated>2021-11-24T15:08:47.751Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">strs</span> = [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">strs</span> = [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>大概有这五种思路, 一般都会采用第四种, 但是耗时太多</p><p>1、所求的最长公共前缀子串一定是每个字符串的前缀子串。所以随便选择一个字符串作为标准，把它的前缀串，与其他所有字符串进行判断，看是否是它们所有人的前缀子串。这里的时间性能是O(m*n*m)。</p><p>2、列出所有的字符串的前缀子串，将它们合并后排序，找出其中个数为n且最长的子串。时间性能为O(n*m+m*n*log(m*n))</p><p>3、纵向扫描：从下标0开始，判断每一个字符串的下标0，判断是否全部相同。直到遇到不全部相同的下标。时间性能为O(n*m)。</p><p>4、横向扫描：前两个字符串找公共子串，将其结果和第三个字符串找公共子串……直到最后一个串。时间性能为O(n*m)。</p><p>5、借助trie字典树。将这些字符串存储到trie树中。那么trie树的第一个分叉口之前的单分支树的就是所求。</p><p>python两种让你拍大腿的解法，时间复杂度你想象不到，短小精悍。 1、利用python的max()和min()，在Python里字符串是可以比较的，按照ascII值排，举例abb， aba，abac，最大为abb，最小为aba。所以只需要比较最大最小的公共前缀就是整个数组的公共前缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> strs: <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    s1 = <span class="built_in">min</span>(strs)</span><br><span class="line">    s2 = <span class="built_in">max</span>(strs)</span><br><span class="line">    <span class="keyword">for</span> i,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(s1):</span><br><span class="line">        <span class="keyword">if</span> x != s2[i]:</span><br><span class="line">            <span class="keyword">return</span> s2[:i]</span><br><span class="line">    <span class="keyword">return</span> s1</span><br></pre></td></tr></table></figure><p>2、利用python的zip函数，把str看成list然后把输入看成二维数组，左对齐纵向压缩，然后把每项利用集合去重，之后遍历list中找到元素长度大于1之前的就是公共前缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> strs: <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    ss = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">set</span>, <span class="built_in">zip</span>(*strs)))</span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(ss):</span><br><span class="line">        x = <span class="built_in">list</span>(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(x) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        res = res + x[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;keyword&quot;&gt;strs&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&amp;quot;flower&amp;quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&amp;quot;flow&amp;quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&amp;quot;flight&amp;quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&amp;quot;fl&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 亲密字符串</title>
    <link href="http://example.com/2021/11/23/leetcode-%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2021/11/23/leetcode-%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-11-23T14:11:39.000Z</published>
    <updated>2021-11-23T14:13:38.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="859-亲密字符串"><a href="#859-亲密字符串" class="headerlink" title="859. 亲密字符串"></a><a href="https://leetcode-cn.com/problems/buddy-strings/">859. 亲密字符串</a></h4><p>给你两个字符串 s 和 goal ，只要我们可以通过交换 s 中的两个字母得到与 goal 相等的结果，就返回 true ；否则返回 false 。</p><p>交换字母的定义是：取两个下标 i 和 j （下标从 0 开始）且满足 i != j ，接着交换 s[i] 和 s[j] 处的字符。</p><ul><li>例如，在 “abcd” 中交换下标 0 和下标 2 的元素可以生成 “cbad” 。</li></ul><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ab&quot;</span>, <span class="keyword">goal</span> = <span class="string">&quot;ba&quot;</span></span><br><span class="line">输出：true</span><br><span class="line">解释：你可以交换 s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span> 和 s[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span> 生成 <span class="string">&quot;ba&quot;</span>，此时 s 和 <span class="keyword">goal</span> 相等。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ab&quot;</span>, <span class="keyword">goal</span> = <span class="string">&quot;ab&quot;</span></span><br><span class="line">输出：false</span><br><span class="line">解释：你只能交换 s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span> 和 s[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span> 生成 <span class="string">&quot;ba&quot;</span>，此时 s 和 <span class="keyword">goal</span> 不相等。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aa&quot;</span>, <span class="keyword">goal</span> = <span class="string">&quot;aa&quot;</span></span><br><span class="line">输出：true</span><br><span class="line">解释：你可以交换 s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span> 和 s[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span> 生成 <span class="string">&quot;aa&quot;</span>，此时 s 和 <span class="keyword">goal</span> 相等。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;aaaaaaabc&quot;</span>, <span class="attr">goal</span> = <span class="string">&quot;aaaaaaacb&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= s.length, goal.length &lt;= 2 * 104</li><li>s 和 goal 由小写英文字母组成</li></ul><p><strong>思路</strong></p><ol><li>字符串长度不相等, 直接返回false</li><li>字符串相等的时候, 只要有重复的元素就返回true</li><li>A, B字符串有不相等的两个地方, 需要查看它们交换后是否相等即可.</li></ol><p><strong>参考答案</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span>(<span class="params">self, s, goal</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type goal: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 长度不同直接false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(goal): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 由于必须交换一次，在相同的情况下，交换相同的字符</span></span><br><span class="line">        <span class="keyword">if</span> s == goal <span class="keyword">and</span> <span class="built_in">len</span>(<span class="built_in">set</span>(goal)) &lt; <span class="built_in">len</span>(goal): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用 zip 进行匹配对比，挑出不同的字符对</span></span><br><span class="line">        dif = [(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(s, goal) <span class="keyword">if</span> a != b]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 对数只能为2，并且对称，如 (a,b)与(b,a)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(dif) == <span class="number">2</span> <span class="keyword">and</span> dif[<span class="number">0</span>] == dif[<span class="number">1</span>][::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/buddy-strings">https://leetcode-cn.com/problems/buddy-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;859-亲密字符串&quot;&gt;&lt;a href=&quot;#859-亲密字符串&quot; class=&quot;headerlink&quot; title=&quot;859. 亲密字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/buddy-strings/&quot;&gt;859. 亲密字符串&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你两个字符串 s 和 goal ，只要我们可以通过交换 s 中的两个字母得到与 goal 相等的结果，就返回 true ；否则返回 false 。&lt;/p&gt;
&lt;p&gt;交换字母的定义是：取两个下标 i 和 j （下标从 0 开始）且满足 i != j ，接着交换 s[i] 和 s[j] 处的字符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，在 “abcd” 中交换下标 0 和下标 2 的元素可以生成 “cbad” 。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Happy Birthday</title>
    <link href="http://example.com/2021/11/22/Happy-Birthday/"/>
    <id>http://example.com/2021/11/22/Happy-Birthday/</id>
    <published>2021-11-22T12:37:45.000Z</published>
    <updated>2021-11-23T14:05:42.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天是我的生日，其实我不喜欢过生日。因为除了我妈没有人记得，也没有人在乎过。</p><p>记得小时候，我12岁的生日我记得很清楚，因为那天我奶奶祭祖，我感觉很隆重，我爸还请了亲戚们吃饭。但我似乎并不是这次的主角，除了大姐没有人跟我说生日快乐。</p><p>最让我感动的一次生日是大一的时候，因为那次我和一个好友的生日是同一天。他下午给我送了礼物，但是我并不在寝室，于是让细心的室友发现了我的“秘密”。</p><span id="more"></span><p>那天天气很冷，我上完晚课加上去实验室自习已是晚上十点。其实那天我猜到了室友可能知道我的生日了，当我回到寝室时，还是被感动的落了泪。第一次有人给我真正的过生日，还给我买了蛋糕。</p><p>简单却温馨</p><p>好像很多人都不爱过生日，因为没人记得，没人会记得，因为很麻烦，会尴尬，因为没有钱，送不起。</p><p>但其实我们要的不是礼物，仅仅是一句生日快乐。</p><p>今天又是我的生日了，没有告诉别人，下班的时候偷偷给自己买了个蛋糕。其实，你不说别人怎么会记得呢，不过一个人有时候也挺好的。</p><p>一个普通平常的一天，如果自己都忘了，谁又能重视呢。</p><p>生日快乐！！！</p><p><img src="1.jpeg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天是我的生日，其实我不喜欢过生日。因为除了我妈没有人记得，也没有人在乎过。&lt;/p&gt;
&lt;p&gt;记得小时候，我12岁的生日我记得很清楚，因为那天我奶奶祭祖，我感觉很隆重，我爸还请了亲戚们吃饭。但我似乎并不是这次的主角，除了大姐没有人跟我说生日快乐。&lt;/p&gt;
&lt;p&gt;最让我感动的一次生日是大一的时候，因为那次我和一个好友的生日是同一天。他下午给我送了礼物，但是我并不在寝室，于是让细心的室友发现了我的“秘密”。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="2021" scheme="http://example.com/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>为什么有些朋友，走着走着就散了</title>
    <link href="http://example.com/2021/11/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E6%9C%8B%E5%8F%8B%EF%BC%8C%E8%B5%B0%E7%9D%80%E8%B5%B0%E7%9D%80%E5%B0%B1%E6%95%A3%E4%BA%86/"/>
    <id>http://example.com/2021/11/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E6%9C%8B%E5%8F%8B%EF%BC%8C%E8%B5%B0%E7%9D%80%E8%B5%B0%E7%9D%80%E5%B0%B1%E6%95%A3%E4%BA%86/</id>
    <published>2021-11-21T14:52:22.000Z</published>
    <updated>2021-11-23T12:39:15.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>01</strong></p><p>可能这样说有些无奈，但<strong>很多友情确实是阶段性的，时间和空间是扼杀友情最大的两个“杀手”。</strong></p><p>曾经，时间和空间的撮合，让我们共享了一段结伴的愉快旅程，<strong>到了分岔路口的时候，你说要去海里看鲸，我说要去林间看鹿，于是就此分道扬镳。</strong></p><p>但我们并不是一夕之间陌生的，刚开始，我们还保持着联系，你给我看看鲸的照片，我和你说说鹿的样貌。但<strong>在不再参与彼此的生活之后，话题的开启渐渐变得困难，从前的默契渐渐不再。</strong></p><span id="more"></span><p>很多次，浮于表面的对话、不再及时的回复、戛然而止的聊天，让彼此都分明感到这种联系成了一种打扰。<strong>成年人有一种精细的敏感和贴心的自觉，一旦感受到对方的退意和冷淡，自己便也很少再主动了，毕竟，大家都忙。</strong></p><p>所以你看，其实什么也没发生，<strong>没有具体的波澜，没有大吵一架，甚至没有结束语，但我们就是不再联系了</strong>，然后，我们不仅消失在了彼此的生活里，也模糊在了彼此的记忆中。</p><p>在时间的冲刷和距离的阻隔下，我们和那个人的联系就这样默默地、悄悄地、势不可挡地斩断了。</p><p><strong>“被推着走，跟着生活流，来年陌生的，是昨日最亲的某某。”</strong>大概，这就是“初闻不识曲中意，再闻已是曲中人”。</p><p><strong>02</strong></p><p>虽然有些直接，但还是要承认，<strong>好友间关系变淡的原因之一，是社会资源、地位、见识差距变大，你的苦闷他无法理解，他的彷徨对你而言，又可能是某种变相的炫耀。</strong></p><p>两个人无话可说，只能叙旧，直到过去被反复咀嚼，淡而无味，又碍于情面，怕被指责势利，还要勉强维持点赞的情分。</p><p><strong>当然，有很多超越阶级的友谊，但两者的见识和思辨力，一定是对等的。</strong>许多年少时的朋友，只能被拿来怀念；许多因为恩情而结缘的人，也只适合报恩。<strong>朋友是需要交换观点的人，而不仅仅是交换感情。</strong></p><p>我越来越觉得，<strong>要从同路者中寻找朋友，而不是硬拽着朋友一道上路。到了分岔口，温柔道别就好，过年时发一句“新年吉祥”，也好过两个人口不对心地把酒话桑麻。</strong>（作者：倪一宁）</p><p><strong>03</strong></p><p><strong>在各奔前程的过程中，旧友不断流失，但在新的环境里，又未能建立起可以弥补这种流失的关系。</strong>我觉得，是这两者的合力，共同酿成了“失友”的感受。</p><p>很多人都有这样的体会吧：<strong>毕业工作后，认识新朋友这件事好像变得越来越困难了，交际圈也很难在工作外有所拓展。</strong>同事可以一起吃饭一起聊天一起玩，但真要成为特别好的知心朋友，似乎不容易。</p><p>这很正常，<strong>毕竟大家是因为工作而聚在一起的，而不是为了交朋友</strong>，况且，当友谊掺杂了公事，又会变得更复杂，顾虑也会更多。</p><p>但这些都不是最重要的，真正的问题好像是：<strong>我们越来越不愿意花精力去交朋友了。</strong>因为工作太累了，有时间就想自己待着多休息，不想在社交上花费力气；因为从零开始了解一个人太麻烦了，已经没有年少时的心气和热情了；因为自己的事情太多了，交朋友已经不是生活的重点了……</p><p><strong>旧的不断流失，新的未有补给</strong>，于是，朋友好像真的越来越少了。</p><p><strong>04</strong></p><p>失去一个朋友，除了因为生活轨迹的差异，也许还有一个内在的原因，那就是：<strong>对方不再是你认可的那个人了。</strong></p><p><strong>能成为朋友，一定有互相欣赏、互相影响、互相促进、互相依靠、互相带来能量和快乐这些因素</strong>，如果有一天，因为各种原因，我们已经无法从对方身上感受和汲取这些<strong>情绪价值</strong>，甚至对方的一些想法和做法是我们无法认可的，渐行渐远也许就在所难免了。</p><p>人生的际遇不断变化，行走其中的人也在不断变化。<strong>怀念过去，并不意味着要停在过去。</strong></p><p><strong>05</strong></p><p>有心理学家说，<strong>18-25岁是所谓的“成年初期”，这个年龄段主要“解决亲密与孤独的冲突”，我们需要朋友带来的亲密关系，以克服内心的孤独、迷茫和不确定感，冲开人生的一道道关卡。</strong>这一时期的交友因素，最重要的是<strong>“接近性”</strong>。</p><p>然后，随着年龄的增长，方向的差异，际遇的变化，<strong>曾经的“接近性”受到破坏，很多曾经的朋友疏于甚至失去联系。</strong></p><p>但是，随着时间推移，成年人的友情其实也在变化。</p><p>我们不再是曾经意气高喊“要做一辈子好朋友”的热血少年，我们不再是连上厕所都要约着一起的亲密同伴，我们更清楚自己想要什么，可以独立做出决定。在这个阶段，<strong>“相似性”</strong>成为更重要的因素，在一些专家看来，<strong>成年中期的友情，不再需要时刻相伴，关系被定义为：知道他在那里。</strong></p><p>是啊，<strong>真正可贵和难得的情谊，不会轻易被时空打败。</strong>哪怕人生的际遇疏离化了一些关系，哪怕彼此的联系不如往日频繁，哪怕已经许久未见，哪怕不能第一时间知晓你的近况，<strong>但在我需要你的时候，我知道你就在那里。</strong></p><p>也许，<strong>我们并没有“失去朋友”，我们只是换了一种方式去维系友情，更成熟地面对人生。</strong></p><p><strong>“大丈夫各乘风波，未始有极，哀乐且不足累上士之心，况小别乎？”</strong></p><p>别离是人生常态，身边的人也确实来来往往更迭不断，但<strong>总有一些人，已经陪伴了我们很久，还将陪伴我们更久。</strong></p><p><img src="1.jpeg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能这样说有些无奈，但&lt;strong&gt;很多友情确实是阶段性的，时间和空间是扼杀友情最大的两个“杀手”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;曾经，时间和空间的撮合，让我们共享了一段结伴的愉快旅程，&lt;strong&gt;到了分岔路口的时候，你说要去海里看鲸，我说要去林间看鹿，于是就此分道扬镳。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但我们并不是一夕之间陌生的，刚开始，我们还保持着联系，你给我看看鲸的照片，我和你说说鹿的样貌。但&lt;strong&gt;在不再参与彼此的生活之后，话题的开启渐渐变得困难，从前的默契渐渐不再。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="2021" scheme="http://example.com/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 分糖果</title>
    <link href="http://example.com/2021/11/11/leetcode-%E5%88%86%E7%B3%96%E6%9E%9C/"/>
    <id>http://example.com/2021/11/11/leetcode-%E5%88%86%E7%B3%96%E6%9E%9C/</id>
    <published>2021-11-11T14:03:06.000Z</published>
    <updated>2021-11-11T14:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="575-分糖果"><a href="#575-分糖果" class="headerlink" title="575. 分糖果"></a><a href="https://leetcode-cn.com/problems/distribute-candies/">575. 分糖果</a></h4><p>Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。</p><p>医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。</p><p>给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的最多种类数。</p><span id="more"></span><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：candyType = [1,1,2,2,3,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：candyType = [1,1,2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：candyType = [6,6,6,6]</span><br><span class="line">输出：1</span><br><span class="line">解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>n == candyType.length</li><li>2 &lt;= n &lt;= 104</li><li>n 是一个偶数</li><li>-105 &lt;= candyType[i] &lt;= 105</li></ul><p>设糖果数为N，由于妹妹只能分到一半的糖果，所以答案不会超过n/2；另一方面，一共有M种，答案也不会超过M</p><p>若M &lt;= n/2，则每种糖果至少可分一颗给妹妹，此时最多能分M个糖果</p><p>若M &gt; n/2，只能分到n/2种糖果，每种糖果分一颗，此时最多能分n/2个糖果</p><p>贪心算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distrubuteCandies</span>(<span class="params">self,candyType</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">len</span>(<span class="built_in">set</span>(candyType)),<span class="built_in">len</span>(candyType)//<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;575-分糖果&quot;&gt;&lt;a href=&quot;#575-分糖果&quot; class=&quot;headerlink&quot; title=&quot;575. 分糖果&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/distribute-candies/&quot;&gt;575. 分糖果&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。&lt;/p&gt;
&lt;p&gt;医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。&lt;/p&gt;
&lt;p&gt;给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的最多种类数。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2021.11的雪</title>
    <link href="http://example.com/2021/11/07/2021-11%E7%9A%84%E9%9B%AA/"/>
    <id>http://example.com/2021/11/07/2021-11%E7%9A%84%E9%9B%AA/</id>
    <published>2021-11-07T12:40:26.000Z</published>
    <updated>2021-11-11T14:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>2021年11月06号晚，下了北京的第一场雪。（过年那段时间的不算哈）</p><p>我之前约了自然博物馆，因为之前鸽了两次，如果再去不就要被拉黑了。所以我早上顶着风雪，还好赶上了12：00入场。</p><span id="more"></span><p><img src="1.jpg"><br></br></p><p><img src="2.jpg"><br></br></p><p><img src="3.jpg"></p><p>礼品店的礼物好像已经不太适合我了（真的有点幼稚）。唉，可能没有童心了，不过这个狗狗还可以。</p><p><img src="4.jpg"><br></br></p><p><img src="6.jpg"></p><p>中午去了KFC，本来是想去吃火锅的，毕竟下雪嘛。但是一个人吃好像没啥感觉，索性就算了，下雪吃冰淇淋也很美的。</p><p><img src="5.jpg"></p><p>在吃饭的时候，就在想才13点啊，一会去哪逛呢？看了看地图，就去了天坛。雪后的天坛很美，后悔没有在早上就来，那时候还在下雪，而且人少，应该会更美。</p><p><img src="7.jpg"><br></br></p><p><img src="8.jpg"><br></br></p><p><img src="9.jpg"></p><p>今年秋天的叶子刚变黄，还没掉完，就下雪了。感觉夏-&gt;秋-&gt;冬都没几天</p><p><img src="10.jpg"></p><p>听说每年下雪去故宫等地方，因为冰锥下落而去整形外科的人很多，还好我没事…</p><p><img src="11.jpg"><br></br></p><p><img src="12.jpg"></p><p>好了，伴随着夕阳，我也要回家了。</p><p><img src="13.jpg"><br></br></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年11月06号晚，下了北京的第一场雪。（过年那段时间的不算哈）&lt;/p&gt;
&lt;p&gt;我之前约了自然博物馆，因为之前鸽了两次，如果再去不就要被拉黑了。所以我早上顶着风雪，还好赶上了12：00入场。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="2021" scheme="http://example.com/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>三体：死神永生</title>
    <link href="http://example.com/2021/11/06/%E4%B8%89%E4%BD%93-%E6%AD%BB%E7%A5%9E%E6%B0%B8%E7%94%9F/"/>
    <id>http://example.com/2021/11/06/%E4%B8%89%E4%BD%93-%E6%AD%BB%E7%A5%9E%E6%B0%B8%E7%94%9F/</id>
    <published>2021-11-06T10:37:19.000Z</published>
    <updated>2021-11-11T14:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>他们都说程心很圣母，但想想她也是被人推上去的。</p><p>在最开始不过是一个PIA（星防御理事会战略情报局）的管理层。维德提出送大脑，程心确实是想到了云天明，毕竟是熟悉的人，所以能想到。</p><span id="more"></span><p>至于云天明对程心的暗恋，不论多感人，不过是感动自己，感动观众而已。被喜欢的人不会因“爱”而感动，这里的爱是爱情的爱，而不是一个人对自己好的情感的爱。</p><p>其实，我们都知道我们被云天明感动的，不过也是一个人对另一个人好，而另外一个人完全不当回事。换做现实生活中的自己又何尝不是！对一个不爱你的人来说，你所做的一切什么都不是。你做出了很大的牺牲，仅仅是感动了她一下而已，觉得有愧于你，但那也不是想和你在一起。</p><p>对于云天明来说，他不需要这个。对于那些喜欢别人而不被他人所爱的人来说，也不需要这种感动。</p><p>之后，在竞选了执剑人的时候，确实是人们选择了圣母的程心。因为人们看到了她的善良，人们需要这种温柔的美。因为罗辑是那个”暴君“，人们害怕他，和平的年代人们总会这样。想想确实很可笑，但书中人人类，是我们每一个人的缩影。像是无法摆脱的枷锁，像是一条无形的锁链，到那个时候人们就是会做出这样的事。</p><p>不过有一点，程心确实被冲昏了头。就是当所有人都觉得程心可以的时候，程心自己也把这个问题想的太过简单了。她在联合国抱着婴儿说自己要竞选执剑人的那一刻，真的是不能忘记，或许将成为是一个经典。</p><p>在她刚刚成为执剑人的那一刻，三体就发起了进攻，她丢掉了遥控器，她按不下去。这其实也是很多人觉得她圣母的时候。但我们并不是程心，我们没有站在程心所站的位置，也没有经历过程心所经历的一切。这也并不是给程心开脱什么，毕竟当她看到被入侵的那一刻，她没有履行自己的职责就不是一个好的执剑人了。但试想一下自己，是否又能在那一刻按下遥控器让所有地球人，三体人全部陪葬呢？</p><p>要知道，当你按下去的那一刻，可能三体会出于报复，对地球进行毁灭性的打击，或者惨无人道的杀戮，又或者地球人自己对程心的谴责等等。毕竟黑暗森林的打击没有那么快么。虽然说三体入侵后对人类的侵占也是很没有人道的，最后竟然让人们互相蚕食。</p><p>想象一下吧，你在单位、学校、家庭等各种场合的畏首畏尾真的可以承担这个大任吗？程心也不过是和我们一样的人。</p><p>不过可能程心对云天明的一直都是一种依靠，而非爱情吧。因为从送星星到三个故事，她的感动都不是那种我想和你在一起，而是一种很温暖的依靠的感觉。这一点也能在最后去他们的那颗星星上可以体现，她渴望见到他，那就是喜欢他吗？并不是，因为看到关一帆的时候，她也有那种依靠感，毕竟当时以为全人类都没有了嘛。</p><p>不过最后云天明和AA在一起了，也是什么伦理剧哈哈哈。公开暗恋我的人，竟然跟我最好的闺蜜在一起了。也算是挺好吧，书中的剧情永远没有现实生活中离谱。</p><p>云天明能放下程心，开始自己的生活就已经很不错了。</p><p>最后程心留下5公斤的生态球，书中为一个开放结局，到底有没有重启不得而知。这样感觉程心也是一个被动型人格的人，容易受到他人的观念所左右。</p><p>说了好的情感话题，其实第三部，死神永生真的很好看，上演了全人类的猜忌、生存大戏。真的是大为震撼，不过还是感觉大刘在这方面刻画的比较少，可能编剧不让过？不过他自己没怎么写过这样的内容吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;他们都说程心很圣母，但想想她也是被人推上去的。&lt;/p&gt;
&lt;p&gt;在最开始不过是一个PIA（星防御理事会战略情报局）的管理层。维德提出送大脑，程心确实是想到了云天明，毕竟是熟悉的人，所以能想到。&lt;/p&gt;</summary>
    
    
    
    <category term="书评" scheme="http://example.com/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
    <category term="2021" scheme="http://example.com/tags/2021/"/>
    
  </entry>
  
</feed>
